<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2013 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<part id="part-architecture">
  <title>Architecture</title>

  <chapter id="chapter-architecture">
    <title>Architecture</title>

    <para>Geomajas is an application framework which allows building powerful
    GIS application. We will try to look at the architecture starting from a
    high level overview, drilling down to discover more details.</para>

    <para>At the highest level, Geomajas makes a distinction between the
    <glossterm>back-end</glossterm> and <glossterm>faces</glossterm>.</para>

    <figure>
      <title>Geomajas back-end and faces</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/backend-faces.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The back-end is where you configure your maps, layers and
    attributes/features. It is always server side. The back-end has an API for
    interaction with the outside world and for extension using plug-ins. While
    one of the main purposes of the back-end is to provide bitmaps and vector
    graphics for the maps and provide data about features to be rendered and
    edited, it contains no display code.</para>

    <para>The actual display and editing is done in the faces. The back-end is
    agnostic of web (or other) display frameworks. Faces are often split in
    two modules, a sever-side module (which directly talks to the back-end
    using java calls) and serializes data to the client, and a client-side
    module which only talks to the server side module. The communication
    between the two modules is private to the face. The face itself provides a
    additional client API. This will typically provide details about available
    widgets, parameters for these widgets and other possible interactions
    (like message queues or topics you can subscribe to).</para>

    <para>The purpose of Geomajas is to provide rich editing of GIS data in
    the browser, but the faces also make other applications possible. You
    could unlock the maps which are configured in Geomajas using a face which
    makes data available as web services (this would result in a face with
    only a server-side module). You could also build a java swing application
    using the Geomajas back-end by writing a swing face. This would result in
    a thick client application (possibly accessible using Java Web
    Start).</para>

    <para>Geomajas contains two faces out-of-the-box.</para>

    <para>The a dojo face, which uses the dojo toolkit JavaScript widget
    library in the browser, is mainly provided for backward compatibility. Up
    until Geomajas 1.4 this was the only face which existed. It integrates
    well with dojo but has the disadvantage that you need to develop in both
    java (for the server side) and JavaScript (for the client side) and that
    debugging can be a challenge.</para>

    <para>Since 1.5 we also provide a GWT face. This allows all development to
    be done in Java and GWT will handle conversion to Javascript for code
    which needs to run in the browser. Obviously this integrates best with GWT
    based applications, but it can be combined with other web frameworks as
    well.</para>

    <figure>
      <title>Geomajas services</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/services.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Geomajas back-end is built from many services which are wired
    together using dependency injection (DI). This wiring is partly done
    automatically, and partly through the configuration files. Thanks to the
    inversion of control (IoC) the back-end is very flexible and can be
    customized at will.</para>

    <para>The client-server communication is done through the command
    dispatcher. This delegates to one of the action based services which
    handle the command. These typically interact with one or more of the topic
    based services (though the command could also handle everything directly).
    The most important built-in topic based services are the raster and vector
    layer service. They are used to access the GIS data which is stored as
    either raster or vector layer.</para>

    <para>All the services are running in a secured zone and will typically
    interact with the security context to verify access rights (or
    policies).</para>

    <para>The layers access the actual GIS data, either directly or using some
    kind of transformation service (for example a GeoServer or MapServer
    instance).</para>

    <figure>
      <title>Geomajas for mashups</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/mashup.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>With this advanced configuration, many integration options exist.
    One example is displayed above, the inclusion of Geomajas in an existing
    application. On the client side, you just have to include the map widget
    in your web application. On the server side, there are many options, but
    you could for example assure that the transactions are shared between your
    existing application and Geomajas.</para>

    <figure>
      <title>Geomajas dependencies</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/dependencies.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>As is the case for most powerful frameworks, Geomajas stands on the
    shoulder of giants. We use some of the major open source libraries in our
    framework (and we integrate with a lot more).</para>

    <figure>
      <title>Geomajas back-end modules</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/backend.png" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The Geomajas back-end is itself built from several modules which are
    tied together using the Spring framework (<ulink
    url="http://springframework.org/">http://springframework.org/</ulink>).
    The Geomajas-api module is a set of interfaces which shields
    implementation details between the different modules. The base plumbing
    and some generic features are provided by the Geomajas-impl module.</para>

    <para>There are four possible ways to extend the back-end.</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>command</emphasis>: commands are used as main
          interaction point between the face (client side) and the Geomajas
          back-end. The retrieval of maps and features, calculations, updates
          on the features and all all other functionalities which are
          available client-side are done using commands.</para>
        </listitem>

        <listitem>
          <para><emphasis>layer</emphasis>: this groups a set of access
          options for all details of the layers of a map. A layer can be
          either raster or vector based. A vector layer can be editable. The
          features describing the objects which are part of the vector layer
          are accessed through the "feature model" which converts generic
          feature objects into something Geomajas can use (this way, there is
          no need for the generic feature objects to implement a "feature"
          interface, allowing the use of pojos). A feature contains a geometry
          and can contain attributes, style and labels. Attributes can be
          complex, including one-to-many and many-to-one relations to other
          objects.</para>
        </listitem>

        <listitem>
          <para><emphasis>pipeline</emphasis>: all Geomajas back-end services
          which deal with layers are implemented using pipelines. A pipeline
          is a list of steps (actions) executed in order. Each pipeline can be
          overwritten for a layer, or you can change the default which is used
          when not overwritten for a layer.</para>

          <para>Configuring pipelines can be used to change the rendering
          method, add additional rendering steps (for example marking the
          editable area on a tile), to introduce caching,...</para>
        </listitem>

        <listitem>
          <para><emphasis>security</emphasis>: these modules contain the
          pluggable security features. You can configure the security services
          which are used to verify the validity of an authentication token and
          return the authorization objects based on it. These authorization
          objects can read the security policies from your (secure) policy
          store.</para>
        </listitem>
      </itemizedlist></para>

    <section id="architecture-command">
      <title>Command</title>

      <figure>
        <title>Geomajas face and commands</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/face-command.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The interaction of the client faces with the Geomajas back-end is
      handled using commands.</para>

      <orderedlist>
        <listitem>
          <para>When a command needs to be invoked (probably as result of a
          user interaction), the client will build a
          <code>CommandRequest</code> object. This contains the name of the
          command to be used, the parameters for the command, and optionally
          the user authentication token and language of the user
          interface.</para>
        </listitem>

        <listitem>
          <para>This object is transferred to the face server. For web
          applications, this will typically be done using an AJAX
          request.</para>
        </listitem>

        <listitem>
          <para>The face server will use this <code>CommandRequest</code> to
          invoke the <code>CommandDispatcher</code> service, which can be
          obtained using the Spring context.</para>
        </listitem>

        <listitem>
          <para>The <code>CommandDispatcher</code> will start by invoking the
          <code>SecurityManager</code> to check whether the execution of the
          requested command is allowed. If it is allowed, the actual Command
          is obtained using the Spring context. The
          <code>CommandResponse</code> object is created and the command is
          executed.</para>
        </listitem>

        <listitem>
          <para>The <code>Command</code> will now do its job, writing the
          results in the <code>CommandResponse</code> object. When problems
          occur during execution of the command, it can either write this into
          the response object or throw an exception.</para>
        </listitem>

        <listitem>
          <para>When the command has executed, if it threw an exception, the
          dispatcher will add this in the response object. It will then
          convert any exceptions in the response object into some messages
          which may be sensible to the user (put the message in the correct
          language in the result object, assuring the "cause" chain is also
          included). Some extra information is also added in the response
          object (like command execution time).</para>
        </listitem>

        <listitem>
          <para>The <code>CommandResponse</code> is returned to the face
          server.</para>
        </listitem>

        <listitem>
          <para>The face server serializes the <code>CommandResponse</code>
          back to the face client.</para>
        </listitem>
      </orderedlist>

      <para>When the command had something to do with rendering, then the
      response object is likely to contain a <code>Tile</code>.</para>
    </section>

    <section id="arch-pipeline">
      <title>Pipelines</title>

      <para>Pipelines are used in Geomajas to allow extreme configurability of
      the services which choose to use them.</para>

      <para>They are comparable with BPM processes. At first sight pipelines
      are much more limited as the steps are always sequential, only allowing
      each step to either continue to the next stop or stop the pipeline.
      Nesting pipelines gives back the expressive power of general BPM
      processes. A step could loop over another pipeline, conditionally
      execute a pipeline, start several pipelines for parallel processing etc.
      An important difference is the configurability of pipelines. Pipelines
      are selected on a combination of pipeline name and the layer on which
      the pipeline operates. When defining pipelines, you can either define
      them from scratch, copy an existing pipeline or copy and extend a
      pipeline. A pipeline can be defined with extension hooks and these hooks
      can be used to add additional pipeline steps. You can also add
      interceptors on a pipeline which introduces some code to execute before
      and after the steps which are intercepted and allows you to skip the
      execution of the intercepted steps.</para>

      <figure>
        <title>Geomajas pipeline architecture</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/pipeline.png" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <section id="arch-plarch">
        <title>Pipeline architecture</title>

        <para>All the layer access services provided by the Geomajas back-end
        are implemented by invoking a pipeline. Using
        <code>PipelineService</code>, blocks of functionality become reusable
        and highly configurable with limited coupling between the
        <emphasis>pipeline step</emphasis>s.</para>

        <para>Some of the services which are implemented as
        <code>PipelineService</code> include:</para>

        <para><itemizedlist>
            <listitem>
              <para><code>RasterLayerService</code>: methods for accessing a
              raster layer, especially getting tiles for a raster
              layer.</para>
            </listitem>

            <listitem>
              <para><code>VectorLayerService</code>: methods for accessing a
              vector layer, for example for getting the features or obtaining
              vector tiles.</para>
            </listitem>
          </itemizedlist>Pipelines can nest. One of the steps in the default
        "vectorLayer.saveOrUpdate" pipeline will loop over all features to be
        updated and invoke the "vectorLayer.saveOrUpdateOne" pipeline for
        each.</para>

        <para>Pipelines are server side only, client access is typically made
        available by invoking a command.</para>

        <para>Pipelines are typically invoked for a specific layer. In that
        case, the default pipeline can be replaced by a layer specific
        pipeline. This way, layer specific configurations (like optimizations
        or specific rendering) can be applied. When a layer does not overwrite
        a pipeline, the default is used. Pipelines are always selected on
        pipeline name. You can create the layer specific pipeline by setting
        the layer id for which it applied. When several pipelines have the
        same steps, you can define the pipeline once, and refer to it later by
        using a pipeline delegate instead of a list of steps.</para>

        <para>A pipeline consists of a number of steps. A pipeline is
        configured using a <code>PipelineInfo</code> object which details the
        pipeline id and steps. When a pipeline is started (using the
        <code>PipelineService</code>) it executes the pipeline steps until the
        pipeline is finished (a status which can be set by one of the steps),
        or until no more steps are available in the pipeline. Each step gets
        two parameters.</para>

        <para><itemizedlist>
            <listitem>
              <para>a context which contains a map of (typed) objects which
              can be used to pass data between the steps (including initial
              parameters for the pipeline).</para>
            </listitem>

            <listitem>
              <para>the result object which can be filled or transformed
              during the pipeline's execution.</para>
            </listitem>
          </itemizedlist></para>

        <para>Pipelines can be extended in two ways. When a pipeline is
        defined, it is possible to include hooks for extensions. These are
        special no-op steps. When a pipeline is defined, your can either
        define all the pipeline steps, or refer to a delegate pipeline
        combined with a map of extension steps. The pipeline will then be
        based on the delegate pipeline with the extensions steps added after
        the hooks with matching names.</para>

        <para>Pipelines can be also enhanced with interceptors. An interceptor
        will intercept a block of consecutive steps, allowing to perform an
        action before and after the block is executed. Depending on the return
        value of the before action, the steps (and optionally the after
        action) can be skipped. This can for example be used to implement
        functionality like caching and auditing.</para>
      </section>

      <section id="arch-pl-app">
        <title>Application in the back-end</title>

        <para>All the methods in both RasterLayerService and
        VectorLayerService are implemented using pipelines.</para>
      </section>
    </section>

    <section id="arch-layer">
      <title>Layer</title>

      <para>The layer extensions allow determining how a layer is built, which
      data is part of the layer, update and creation of extra data on a
      layer.</para>

      <para>A <code>Layer</code> has some metadata (id, coordinate system,
      label, bbox, stored in the <code>LayerInfo</code> object) and allows you
      get obtain the layer data.</para>
    </section>

    <section id="arch-securiry">
      <title>Security</title>

      <para>The data which is accessed using Geomajas can be security
      sensitive. Geomajas includes all the measures to assure protection of
      sensitive or private data.</para>

      <section id="arch-sec">
        <title>Security architecture</title>

        <para>Geomajas is built to be entirely independent of the
        authentication mechanism and the way to store policies.</para>

        <para>Based on the user who is logged into the system, the following
        restrictions can apply:</para>

        <itemizedlist>
          <listitem>
            <para>access rights to a command</para>
          </listitem>

          <listitem>
            <para>access rights for a layer</para>
          </listitem>

          <listitem>
            <para>a filter which needs to be applied for a layer</para>
          </listitem>

          <listitem>
            <para>a region which limits the data which may be accessed for a
            layer</para>
          </listitem>

          <listitem>
            <para>access rights on the features</para>
          </listitem>

          <listitem>
            <para>access rights on the individual attributes of the
            features</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Security architecture</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security.png" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>To assure the authentication mechanism is pluggable, an
        <emphasis>authentication token</emphasis> is used. The authentication
        token is used to determine the <emphasis>security context</emphasis>.
        The security context contains the <emphasis>policies</emphasis> which
        apply and which can be queried.</para>

        <para>A list of <emphasis>security services</emphasis> can be defined
        (using Spring bean <code>security.SecurityInfo</code>). This list can
        be overwritten in configuration. By default the list is empty, which
        prohibits all access to everyone. The back-end does however include a
        security service which can be used to allow all access to
        everyone.</para>

        <para>The security service is responsible for converting the
        authentication token into a list of <emphasis>authorization
        objects</emphasis>. The security manager will loop all configured
        security services (using Spring bean
        <code>security.SecurityInfo</code>) to find all the authorization
        objects which apply for the token. By default the security manager
        will stop looping once one of the security services gave a result. You
        can change this behaviour to always combine the authorization objects
        from all security services.</para>

        <note>
          <para>The system explicitly allows authentication tokens to be
          generated by different authentication servers. In that case for each
          authentication server, at least one security service should be
          configured in Geomajas. However, when using such a configuration,
          you <emphasis>have to</emphasis> verify that the authentication
          tokens which are generated by the different servers cannot be the
          same.</para>
        </note>

        <para>In many systems (including RBAC systems) an authorization object
        matches a roles for the authenticated user.</para>

        <para>Note that, as the actual authentication mechanisms are handled
        by the security services, Geomajas does not know any passwords or
        credentials. Similarly the secure, tamper-proof storage of policies is
        not handled by Geomajas either.</para>

        <para>Details about the current authentication token and access to the
        policies (using the authorization objects) is available using the
        <code>SecurityContext</code>. The security context is thread specific.
        When threads are reused between different users, the security context
        needs to be cleared at the end of a request (group). This is normally
        handled by the faces.</para>

        <para>The following general authorization checks exist:</para>

        <itemizedlist>
          <listitem>
            <para><code>isToolAuthorized(String toolId)</code>: true when the
            tool can be used. The "toolId" matches the "id" parameter which is
            used in the configuration as specified using the
            <code>ToolInfo</code> class.</para>
          </listitem>

          <listitem>
            <para><code>isCommandAuthorized(String commandName)</code>: true
            when the command is allowed to be called. The "commandName"
            parameter is the same as the command name which is passed to the
            <code>CommandDispatcher</code> service.</para>
          </listitem>
        </itemizedlist>

        <para>And for each layer:</para>

        <itemizedlist>
          <listitem>
            <para><code>isLayerVisible(String layerId)</code>: true when (part
            of) the layer is visible.</para>
          </listitem>

          <listitem>
            <para><code>isLayerUpdateAuthorized(String layerId)</code>: true
            when (some of) the visible features may be editable.</para>
          </listitem>

          <listitem>
            <para><code>isLayerCreateAuthorized(String layerId)</code>: true
            when there is an area in which features can be created.</para>
          </listitem>

          <listitem>
            <para><code>isLayerDeleteAuthorized(String layerId)</code>: true
            when (some of) the visible features may be deleted.</para>
          </listitem>

          <listitem>
            <para><code>getVisibleArea(String layerId)</code>: only the area
            inside the returned geometry is visible (uses layer coordinate
            space). All features which fall outside the layer's MaxExtent area
            are also considered not visible.</para>
          </listitem>

          <listitem>
            <para><code>getUpdateAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry may contain updatable
            features (uses layer coordinate space). All features which fall
            outside the layer's MaxExtent area are also considered not
            updatable.</para>
          </listitem>

          <listitem>
            <para><code>getCreateAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry can new features be created
            (uses layer coordinate space). All features which fall outside the
            layer's MaxExtent area are also considered not creatable.</para>
          </listitem>

          <listitem>
            <para><code>getDeleteAuthorizedArea(String layerId)</code>: only
            the area inside the returned geometry may contain deletable
            features (uses layer coordinate space). All features which fall
            outside the layer's MaxExtent area are also considered not
            deletable.</para>
          </listitem>

          <listitem>
            <para><code>getFeatureFilter(String layerId)</code>: get an
            additional filter which needs to be applied when querying the
            layer's features.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureVisible(String layerId, InternalFeature
            feature)</code>: check the visibility of a feature.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureUpdateAuthorized(String layerId,
            InternalFeature feature)</code>: check whether a feature is
            editable.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureUpdateAuthorized(String layerId,
            InternalFeature oldFeature, InternalFeature newFeature)</code>:
            check whether the update contained in the feature is allowed to be
            saved.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureCreateAuthorized(String layerId,
            InternalFeature feature)</code>: check whether a feature is
            allowed to be created.</para>
          </listitem>

          <listitem>
            <para><code>isFeatureDeleteAuthorized(String layerId,
            InternalFeature feature)</code>: check whether deleting the
            specific feature is allowed.</para>
          </listitem>

          <listitem>
            <para><code>isAttributeReadable(String layerId, InternalFeature
            feature, String attributeName)</code>: check the readability of an
            attribute. The result can be feature specific.</para>
          </listitem>

          <listitem>
            <para><code>isAttributeWritable(String layerId, InternalFeature
            feature, String attributeName)</code>: check whether an attribute
            is editable. The result can be feature specific.</para>
          </listitem>
        </itemizedlist>

        <para>These authorizations are split in several groups. The security
        service is not required to provide an implementation of each
        authorization test (see API), the security context always ensures that
        all methods are available.</para>

        <para>Checking authentication and fetching the authorization details
        can be time consuming (not to mention the hassle of logging in again).
        To solve this, the results of the security services can be cached.
        When a security service can authenticate a token, the reply can
        contain details about the allowed caching. Three parameters are
        allowed to be passed, the <code>validUntil</code> and
        <code>invalidAfter</code> timestamps and an <code>extendValid</code>
        duration.</para>

        <para>The security manager first checks the cache to find (valid)
        authentication results. A cache entry is only valid until the
        "validUntil" timestamp. When an entry is valid, validUntil may be
        extended until "now" plus "extendValid" duration. However,
        "validUntil" is never extended past "invalidAfter". When no data can
        be found in the cache, the security services are queried.<note>
            <para>There may be multiple authentications stored for a
            authentication token. When one of them becomes invalid, they are
            all considered invalid.</para>
          </note><note>
            <para>Entering credentials is never handled by Geomajas. When the
            authentication token cannot be verified, a security exception is
            thrown. It is up to the client application (the face probably) to
            assure that a new authentication token is created.</para>
          </note></para>

        <para>The authorization have two possible results. When reading or
        rendering, all unauthorized data should be filtered without warning or
        exception. When trying to invoke a command or to create, update or
        delete, any attempt which is not authorized should result in a
        security exception.</para>

        <para>The security uses the approach that all access is forbidden
        unless is is allowed. Hence, you will always need to configure at
        least one security service to assure the system is usable.</para>
      </section>

      <section id="arch-sec-comm">
        <title>Interaction between client and back-end</title>

        <para>When a user wants to access a secured Geomajas application, she
        will normally surf to the URL for the application.</para>

        <para>The application will then check whether the user is logged in.
        If that is not the case, the user is redirected to the login page.
        This may be an external page as provided by an authentication server
        (as often used for SSO (Single-Sign-On) solutions), or it could be a
        login widget. Note that the framework does not handle this redirection
        itself or even know how the login can be handled. It is up to the
        application writer to provide this redirection.</para>

        <para>The login page will ask the user to provide her credentials.
        This could be a user name, password pair, a request for a code coming
        from a hardware device, login using a eID or some other means PKI
        (Private Key Infrastructure), automatic recognition based on IP
        address,... When the login handling is satisfied with the provided
        credentials (the user is really authenticated), it will redirect back
        to the original application with a security token.</para>

        <para>This token is then used by the client to pass authentication
        information to the back-end.</para>

        <para>As seen from this example, the Geomajas client does not handle
        the authentication and does not need to know he credentials for the
        user.</para>

        <figure>
          <title>Logging into a Geomajas system</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security-login.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <note>
          <para>It is important to know that the security token typically has
          a limited validity. As such, it can happen at any moment that the
          token is no longer valid and the login screen needs to be presented
          again. The application author should consider this while
          developing.</para>
        </note>

        <para>At the back-end, the programmer has a reasonably simple job. At
        each policy enforcement point, you need an injected security context
        which can be used for the policy decisions. This can be included using
        the following piece of code.</para>

        <informalexample>
          <programlisting>@Autowired
private SecurityContext securityContext;</programlisting>
        </informalexample>

        <para>The framework handles the instantiation of this security context
        based on the security token (which is typically received either
        through the CommandDispatcher's request or a URL parameter). This is
        done by the SecurityManager. The SecurityManager uses the
        configuration supplied by Spring bean
        <code>security.SecurityInfo</code>. Each of the security services will
        check whether the token is valid (which includes checking whether it
        was supplied by the authentication services which backs the service)
        and extract the principal from the token. That principal is used to
        fill some information about the user (like name, to allow the client
        to display this) and to read the policies from the policy store. The
        policies are converted by the service to Authentication objects. The
        authentication objects are combined in the security context, only
        allowing things which are allowed by at least one authentication
        object.</para>

        <figure>
          <title>Building the security context</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/security-context.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Both the authentication service and policy store are outside of
        the Geomajas framework. They can be external services which are
        accessed by the security services or implemented as part of the
        security service implementation.</para>
      </section>

      <section id="arch-sec-app">
        <title>How is this applied ?</title>

        <para>The security is applied throughout Geomajas. A list of places
        (which is not necessarily complete) and some additional ideas for
        application follow.</para>

        <para>Back-end services:</para>

        <itemizedlist>
          <listitem>
            <para><code>CommandDispatcher</code> verifies the existence of a
            <code>SecurityContext</code> and creates one if needed.</para>
          </listitem>

          <listitem>
            <para><code>CommandDispatcher</code> verifies whether the command
            is allowed to be used.</para>
          </listitem>
        </itemizedlist>

        <para>VectorLayerService:</para>

        <itemizedlist>
          <listitem>
            <para>Check layer access.</para>
          </listitem>

          <listitem>
            <para>Handle the "filter" for the layer (if any).</para>
          </listitem>

          <listitem>
            <para>Filter on visible area as this can increase query
            speed.</para>
          </listitem>

          <listitem>
            <para>Post-process features filtering unreadable attributes, set
            update flags, remove features which are not allowed.</para>
          </listitem>
        </itemizedlist>

        <para>Commands:</para>

        <itemizedlist>
          <listitem>
            <para>configuration.Get and configuration.GetMap: layers which are
            invisible should be removed, tools which are not authorized should
            be removed, "editable" and "deletable" statusses on layers,
            features, attributes need to be set.</para>
          </listitem>

          <listitem>
            <para>configuration.UserMaximumExtent: max extent should only
            consider visible features.</para>
          </listitem>

          <listitem>
            <para>feature.PersistTransaction: making changes to attributes
            which are not editable should cause a security exception.</para>
          </listitem>

          <listitem>
            <para>feature.SearchByLocation: only return visible features and
            readable attributes.</para>
          </listitem>

          <listitem>
            <para>feature.SearchFeature: only return visible features and
            readable attributes.</para>
          </listitem>

          <listitem>
            <para>geometry.Get: only return the geometry for visible
            features.</para>
          </listitem>

          <listitem>
            <para>geometry.MergePolygon: no security implications.</para>
          </listitem>

          <listitem>
            <para>geometry.SplitPolygon: no security implications.</para>
          </listitem>

          <listitem>
            <para>render.GetRasterTiles: should only return data for visible
            layers, ideally post-processing the image to ensure only visible
            area is included (making the rest transparent).</para>
          </listitem>

          <listitem>
            <para>render.GetVectorTile: should only return data for visible
            layers, only display visible features, only return visible
            features, only render visible features. When attributes need to be
            included, only readable attributes should be included and the
            "editable" flag needs to be set.</para>
          </listitem>
        </itemizedlist>

        <para>Rendering:</para>

        <itemizedlist>
          <listitem>
            <para>The individual rendering steps (especially the layer/feature
            model) can use the <code>SecurityContext</code> to filter the data
            they produce.</para>
          </listitem>

          <listitem>
            <para>Images can have areas masked which are not allowed to be
            seen.</para>
          </listitem>

          <listitem>
            <para>The rendering pipeline can include steps which check the
            security. This can make life easier on the layer model which are
            not guaranteed (or forced) to handle all security aspects. These
            are active by default but can be removed for speed (when you are
            sure this is double work).</para>
          </listitem>
        </itemizedlist>

        <para>Cache:</para>

        <itemizedlist>
          <listitem>
            <para>The caching needs to consider the access rights when storing
            and retrieving data.</para>
          </listitem>
        </itemizedlist>

        <para>Face:</para>

        <itemizedlist>
          <listitem>
            <para>The face is responsible for assuring a authentication token
            is included in all access to the back-end.</para>
          </listitem>

          <listitem>
            <para>The "get configuration" commands filter the data to assure
            invisible layer and attributes and tools which are not allowed are
            not displayed. No action needed.</para>
          </listitem>

          <listitem>
            <para>Specific tests on editability of individual features and
            attributes would be useful to assure the user does try to enter or
            modify data which cannot be saved.</para>
          </listitem>

          <listitem>
            <para>The face should ask for credentials again when the token was
            not available or is no longer valid. Specifically when a
            <code>GeomajasSecurityException</code> is received which code
            <code>ExceptionCode.CREDENTIALS_MISSING_OR_INVALID</code>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="arch-sec-transport">
        <title>Server configuration</title>

        <para>While this is not really touched by description above, the
        following system configuration issues are likely to be important when
        you want to secure your Geomajas application.</para>

        <itemizedlist>
          <listitem>
            <para>Make sure the communication between the client and server
            uses encryption, possibly by using https. This prevents snooping
            of your data and/or hijacking the security token.</para>
          </listitem>

          <listitem>
            <para>Even if your application is using http for some reason, at
            the very least your authentication method should use https to
            prevent your passwords from being transmitted on the wire in
            cleartext. I would expect all authentication servers do
            this.</para>
          </listitem>

          <listitem>
            <para>Depending on your needs, it may make sense to store the data
            encrypted on the server. If you want that, your need a layer model
            which can access your secured data (possibly passing on the
            security token).</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </chapter>

  <chapter id="backend-ch-plugins">
    <title>Plug-ins</title>

    <para>Geomajas provides a basic set of functionality as part of the
    back-end core. This can be extended and made available using plug-ins. One
    of the functions of the back-end core is to act as a plug-in container.
    Plug-ins are optional libraries that extend the core functionality by
    taking advantage of the public API. There are three special types of
    plug-ins, faces, layers and security plug-ins. which provide extra
    features, faces, layers and other plu</para>

    <para>Faces provide external interfaces for Geomajas. These give access to
    users or external systems to the configured data. The faces which are
    included in the Geomajas project are</para>

    <para><itemizedlist>
        <listitem>
          <para>GWT face : our recommended face for displaying and editing GIS
          data in the browser. This allows you to build your web user
          interface in Java.</para>
        </listitem>

        <listitem>
          <para>dojo face : a face which allows web display and editing using
          dojo toolkit. The user interface needs to be developed using
          JavaScript.</para>
        </listitem>
      </itemizedlist>The layer plug-ins provide access to the actual data
    which needs to be displayed as part of a maps. There are basically two
    types of layers, providing either raster data (bitmaps) or vector data.
    The layers which are provided as part of the normal distribution
    include</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>geomajas-layer-hibernate</emphasis> (vector): allow
          access to any kind of features which are stored in a spatial
          (relational) database. The data is accessed using the hibernate and
          hibernate-spatial open source libraries.</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-layer-geotools</emphasis> (vector): access
          data from any vector data source which has a GeoTools data store
          defined for it (<ulink
          url="http://geotools.org/javadocs/org/geotools/data/DataStore.html">http://geotools.org/javadocs/org/geotools/data/DataStore.html</ulink>).</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-layer-google</emphasis> (raster): include
          Google rasters. This allows access to the normal and satellite views
          provided by Google. You still have to make sure you comply with
          Google terms of use (<ulink
          url="http://code.google.com/apis/maps/">http://code.google.com/apis/maps/</ulink>).</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-layer-openstreetmap</emphasis> (raster):
          support for raster data coming from the OpenStreetMap project
          (<ulink
          url="http://www.openstreetmap.org/">http://www.openstreetmap.org/</ulink>).</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-layer-wms</emphasis> (raster): access data
          from a WMS server (<ulink
          url="http://www.opengeospatial.org/standards/wms">http://www.opengeospatial.org/standards/wms</ulink>).</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-layer-shapeinmem</emphasis> (vector):
          access data from an ESRI shape file which handled in memory. The
          actual data access if done using GeoTools (<ulink
          url="http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf">http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf</ulink>).</para>
        </listitem>
      </itemizedlist></para>

    <para>Other plug-ins allow extensions in functionality, either by
    providing additional commands or extending the rendering pipelines, or
    they provide additional security services.</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>geomajas-command</emphasis>: set of commands which
          are provided as part of the standard distribution. This is so
          fundamental to using Geomajas that it is provided as a back-end
          module.</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-plugin-printing</emphasis>: printing
          extensions for the framework</para>
        </listitem>

        <listitem>
          <para><emphasis>geomajas-plugin-staticsecurity</emphasis>: a basic
          security service which can be configured as part of the Spring
          configuration and does not use an external source for users or
          policies, making the security configuration entirely static.</para>
        </listitem>
      </itemizedlist></para>

    <para>The back-end also contains a set of spatial services. These include
    services for accessing raster and vector services and a set of utility
    services.</para>
  </chapter>

  <chapter id="ch-projstruct">
    <title>Project structure</title>

    <para>The project is built from a large set of modules. A specific
    application can choose which modules are used or not. In principle, the
    back-end module are always required and at least one face and at least one
    layer plug-in. More plug-ins or faces can be added as needed.</para>

    <para></para>

    <section id="arch-auto-reg">
      <title>Face and plug-in registration</title>

      <para>Plug-ins (which include faces) are automatically discovered when
      available on the classpath. This is done using two files:
      META-INF/geomajasContext.xml and META-INF/geomajasWebContext.xml.</para>

      <para>The geomajasContext.xml file contains information about the
      plug-in, the dependencies for the plug-in (which are checked when the
      application context is built, assuring that the set of plug-ins is
      complete and can be combined) and contains copyright and license
      information for the plug-in and its dependencies. Additional beans and
      services can also be defined.</para>

      <para>The geomajasWebContext.xml file is provided to allow additional
      endpoints to be added in the web tier. Geomajas normally installs a
      <code>DispatcherServlet</code> in the web.xml file to allow additional
      web endpoints to be added using Spring MVC.</para>
    </section>

    <section id="arch-module">
      <title>Module Overview</title>

      <para>Different modules have different impacts and different purposes.
      Therefore different categories of modules are required. Geomajas has
      defined the following set of module categories (matching the directories
      in the source):</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis role="">application</emphasis>: working examples
            of applications using the Geomajas GIS framework.</para>
          </listitem>

          <listitem>
            <para><emphasis>backend</emphasis>: these are essential Geomajas
            modules. Each Geomajas application needs these modules. However,
            you also need some a face and some plug-ins (like layers) or you
            won't be able to do much.</para>
          </listitem>

          <listitem>
            <para><emphasis>build-tools</emphasis>: some modules which are
            useful for starting or building Geomajas or a Geomajas
            project.</para>
          </listitem>

          <listitem>
            <para><emphasis>documentation</emphasis>: documentation modules,
            specifically the different Geomajas guides. These are the general
            guides, each of the plug-ins also has a documentation
            module.</para>
          </listitem>

          <listitem>
            <para><emphasis>face</emphasis>: faces that present a certain
            Geomajas client interface to the user.</para>
          </listitem>

          <listitem>
            <para><emphasis>plugin</emphasis>: modules that extend Geomajas.
            This can either add new functionality, add support for a certain
            type of data source, provide a security service or a
            combination.</para>
          </listitem>

          <listitem>
            <para><emphasis>project</emphasis>: these are projects which can
            be used independently of the Geomajas back-end.</para>
          </listitem>

          <listitem>
            <para><emphasis>test</emphasis>: modules which are used for
            (integration) testing of Geomajas.</para>
          </listitem>
        </itemizedlist> Full list of Geomajas modules:</para>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas application modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-gwt-example</entry>

              <entry>Example application using the GWT face which serves both
              as showcase and test application. This is currently an oldish
              application, replaced by the geomajas-gwt-showcase
              module.</entry>
            </row>

            <row>
              <entry>geomajas-gwt-showcase</entry>

              <entry>Example application using the GWT face which serves as
              showcase for various aspects of the framework. This aggregates
              the example/test modules which are included in the GWT face and
              the various plug-ins.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas back-end modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-api</entry>

              <entry>Stable interfaces. Reference guide for other
              modules.</entry>
            </row>

            <row>
              <entry>geomajas-api-experimental</entry>

              <entry>Experimental interfaces. This contains some experimental
              stuff which may be promoted to the supported API when useful, or
              may be changed or dumped. As this is <emphasis>not</emphasis>
              part of the API, it may change between revisions.</entry>
            </row>

            <row>
              <entry>geomajas-command</entry>

              <entry>Lists all basic commands.</entry>
            </row>

            <row>
              <entry>geomajas-common-servlet</entry>

              <entry>Code which is shared by the different faces which are
              servlet based.</entry>
            </row>

            <row>
              <entry>geomajas-impl</entry>

              <entry>Main library with default implementations.</entry>
            </row>

            <row>
              <entry>geomajas-testdata</entry>

              <entry>Module which contains data which is used for testing
              Geomajas.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas build-tools modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-checkstyle</entry>

              <entry>Module which contains the checkstyle definitions which
              should be adhered to for all code in the Geomajas source
              tree.</entry>
            </row>

            <row>
              <entry>geomajas-dep</entry>

              <entry>This module can be included in your
              "dependencyManagement" section to set default versions for many
              possible dependencies. This includes the current release
              versions of all Geomajas project modules and their major
              dependencies. The versions can always be overwritten in your
              pom. It does not indicate that module versions play well
              together (though they should if the API contract is adhered).
              This module should never contain snapshot builds.</entry>
            </row>

            <row>
              <entry>geomajas-maven-dojo</entry>

              <entry>Maven plugin which helps to combine all the JavaScript
              code for dojo, Geomajas and the project itself. This is usually
              referred to as the "shrink" or "shrinksafe" step.</entry>
            </row>

            <row>
              <entry>geomajas-maven-plugin</entry>

              <entry>Maven plugin which is used for generating the
              documentation. It extracts excerpts from the code to allow
              inclusion in the docbook guides.</entry>
            </row>

            <row>
              <entry>geomajas-parent</entry>

              <entry>Parent pom which includes some Geomajas specific settings
              like copyright, java version, checkstyle etc.</entry>
            </row>

            <row>
              <entry>geomajas-al-parent</entry>

              <entry>Parent pom which should be used for Apache licensed
              modules (extends the normal geomajas-parent).</entry>
            </row>

            <row>
              <entry>geomajas-doc-parent</entry>

              <entry>Parent pom which should be used for documentation
              modules. This has all the details to enable building the
              documentation in HTML and PDF format from the docbook
              sources.</entry>
            </row>

            <row>
              <entry>geomajas-gwt-archetype</entry>

              <entry>Archetype to build a skeleton application which uses the
              GWT face.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-archetype</entry>

              <entry>Archetype to build a skeleton for a new plugin.</entry>
            </row>

            <row>
              <entry>geomajas-jetty-runner</entry>

              <entry>Jetty runner which can be used in Eclipse IDE to easy
              running Geomajas applications.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas documentation modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>contributorguide</entry>

              <entry>Guide for contributors to the project. Includes
              information about compilation of the project, coding style, how
              to contribute to the documentation, JIRA guidelines etc.</entry>
            </row>

            <row>
              <entry>devuserguide</entry>

              <entry>Guide for developers who want to use Geomajas in their
              applications.</entry>
            </row>

            <row>
              <entry>enduserguide</entry>

              <entry>Guide for end-users who use the Geomajas widgets. This
              guide should probably be included in the application
              documentation.</entry>
            </row>

            <row>
              <entry>style</entry>

              <entry>Style module for conversion of the docbook files to
              usable output.</entry>
            </row>

            <row>
              <entry>xslt</entry>

              <entry>Transformation module for conversion of the docbook files
              to usable output.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas project modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-project-api</entry>

              <entry>Project to make the API annotations reusable.</entry>
            </row>

            <row>
              <entry>geomajas-project-geometry</entry>

              <entry>Project which contains a set of geometry DTOs and
              services with minimal dependencies. There are services to
              manipulate the geometries and to convert to JTS
              geometries.</entry>
            </row>

            <row>
              <entry>geomajas-project-sld</entry>

              <entry>Project which contains a set of DTOs for handling SLD.
              There are also services to convert between the DTO and
              XML.</entry>
            </row>

            <row>
              <entry>geomajas-project-sld-editor</entry>

              <entry>An SLD editor which used the SLD DTOs.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas face modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-face-dojo</entry>

              <entry>Modules for the dojo face, including
              documentation.</entry>
            </row>

            <row>
              <entry>geomajas-face-gwt</entry>

              <entry>Modules for the GWT face, including the
              documentation.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas plug-in modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-layer-geotools</entry>

              <entry>Support for any data format GeoTools supports.</entry>
            </row>

            <row>
              <entry>geomajas-layer-google</entry>

              <entry>Support for GoogleMaps raster format.</entry>
            </row>

            <row>
              <entry>geomajas-layer-hibernate</entry>

              <entry>Support for database formats through Hibernate.</entry>
            </row>

            <row>
              <entry>geomajas-layer-openstreetmap</entry>

              <entry>Support for OpenStreetMap raster format.</entry>
            </row>

            <row>
              <entry>geomajas-layer-wms</entry>

              <entry>Support for the WMS raster format.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-caching</entry>

              <entry>Caching plug-in which allows improved speed by
              calculating data only once.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-editing</entry>

              <entry>Powerful editing of geometries.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-geocoder</entry>

              <entry>Geocoder support, using various geocoding
              services.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-javascript-api</entry>

              <entry>Standard JavaScript API for communicating with a Geomajas
              map in the browser.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-printing</entry>

              <entry>Adds printing capabilities beyond printing in the
              browser, by delivering the map as PDF.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-rasterizing</entry>

              <entry>Rasterize vector layers on the server.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-reporting</entry>

              <entry>Build reports (using JasperReports) for features,
              possibly including a map.</entry>
            </row>

            <row>
              <entry>geomajas-plugin-staticsecurity</entry>

              <entry>Simple security service which allows including the entire
              security configuration in the Spring configuration files, making
              the configuration static.</entry>
            </row>

            <row>
              <entry>geomajas-widget-advancedviews</entry>

              <entry>Support for advanced views and theming the map in the GWT
              face.</entry>
            </row>

            <row>
              <entry>geomajas-widget-featureinfo</entry>

              <entry>Extra widgets for displaying feature information in the
              GWT face.</entry>
            </row>

            <row>
              <entry>geomajas-widget-searchandfilter</entry>

              <entry>Advanced search and filter widgets for the GWT
              face.</entry>
            </row>

            <row>
              <entry>geomajas-widget-utility</entry>

              <entry>Extra widgets for the GWT face. Includes Ribbon (advanced
              toolbar), Wizard,...</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table cellpadding="" cellspacing="10" class="">
        <title>List of Geomajas test modules</title>

        <tgroup align="left" cols="2">
          <colspec colnum="1" colwidth="1*" />

          <colspec colnum="2" colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Purpose</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>geomajas-test-plainhtml</entry>

              <entry>Test/showcase for integrating a Geomajas map in a plain
              HTML page.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
</part>
