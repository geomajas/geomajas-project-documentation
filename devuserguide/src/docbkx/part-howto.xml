<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2011 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<part id="part-howto">
  <title>How-to</title>

  <chapter id="ch-howto-command">
    <title>Writing your own commands</title>

    <para>A Geomajas command usually consist of three classes, the actual
    command (which implements the <code>Command</code> interface), and two
    data transfer objects, one to pass the request parameters (extending
    <code>CommandRequest</code>, <code>LayerIdCommandRequest</code> or
    <code>LayerIdsCommandRequest</code>), and one which carries the response
    (extending <code>CommandResponse</code>).</para>

    <para>It is important to assure your request object extends from
    LayerIdCommandRequest or LayerIdsRequest when one of the parameters is the
    layer id (or a list thereof). This can be used by the command dispatcher
    to assure the layer specific (transaction) interceptors are called.</para>

    <para>To create a new command we recommend you use a similar package
    structure as we used in the geomajas-extension-command module. That is to
    create a "command" package with under that a "dto" package which contains
    all the request and response objects, and to put the actual commands in
    sub packages based on some kind of grouping. This helps to automatically
    determine a sensible command name.</para>

    <para>The basic command implementation looks like this:</para>

    <xi:include href="listing/ExampleCommand.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>Note the presence of the "@Component" annotation which assures the
    command is registered. You could add the name under which the command
    needs to be registered in the annotation, but when that is omitted, the
    default command name is derived from the fully qualified class name. In
    the example given here this results in command name
    "command.mysuper.DoIt".</para>

    <para>The default way to determine the command name assumes there is a
    package named "command" in the fully qualified name of the implementing
    class. It will remove everything before that. It will then remove a
    "Command" suffix if any. Lastly, it will remove duplication between the
    intermediate package (between "command" and the class name) and the class
    name itself. Some examples:</para>

    <para><table>
        <title>Samples of command name resolution</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Fully qualified class name</entry>

              <entry>Command name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>my.app.command.DoIt</entry>

              <entry>command.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoIt</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.SuperDoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItSuperCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoIt</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandSuperDoIt</entry>

              <entry>command.super.CommandSuperDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoItSuper</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para>You have to include a line in your Spring configuration to scan
    class files for annotation to make the components available. For the case
    above, this could be done by including the following XML fragment in one
    of your Spring configuration files.</para>

    <xi:include href="listing/ExampleCommandScan.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>The command will be executed using a singleton. The use of object
    variables is not recommended. Any object variables will be shared amongst
    all command invocation, which can be coming from multiple threads at the
    same time.</para>

    <para>Note that it is not mandatory to create your own request and
    response object classes. If you don't require any parameters you can use
    <code>EmptyCommandRequest</code> as request class. If you only require a
    layer id, then use <code>LayerIdCommandRequest</code>. If you only return
    a success code, you could use the <code>SuccessCommandResponse</code>
    class.</para>

    <para>You have to take care that all objects which are referenced by your
    request and response objects are actually serializable for the faces in
    which the commands need to be used. For the dojo face this may require the
    use of the "<code>@Json</code>" annotation to exclude fields. For GWT you
    have to assure the no-arguments constructor exists and that the class can
    be compiled by GWT (no Hibernate enhanced classes, no use of
    "<code>super.clone()</code>",...).</para>

    <para>When the commands are included in a separate module, you should
    assure the sources are available as these are needed for GWT compilation.
    This can easily be done using the Maven source plugin.</para>

    <xi:include href="listing/MavenSourcePlugin.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>Actually including the sources can then be done using a dependency
    like the following (this includes the staticsecurity module, both the
    actual code and the sources). You could set "provided" scope on the source
    dependency to exclude it from the war file. However, this may prevent use
    of GWT development mode.</para>

    <xi:include href="listing/StaticSecurityDependency.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para></para>
  </chapter>

  <chapter id="ch-howto-plugin">
    <title>Create a plug-in</title>

    <para>The general procedure for creating a new plug-in is described here.
    Additional information for specific types of plug-ins is described in
    subsequent chapters.</para>

    <section id="pi-arch">
      <title>Using the plug-in archetype</title>

      <para>TODO.....</para>
    </section>

    <section id="pi-struct">
      <title>Plug-in structure</title>

      <para>TODO.....</para>
    </section>

    <section id="pi-depdec">
      <title>Plug-in declaration and dependencies</title>

      <para>TODO.....</para>
    </section>
  </chapter>

  <chapter id="ch-howto-layer">
    <title>Create a layer plug-in</title>

    <para>Layers allow access to data which needs to be displayed in a
    map.</para>

    <para>For the existing layers, the details about configuring you map to
    include that layer are included in the <link
    linkend="backend-ch-configuration">configuration</link> section
    above.</para>

    <section id="writlay">
      <title>Writing your own layer</title>

      <para>TODO.....</para>
    </section>
  </chapter>

  <chapter id="ch-howto-security-plugin">
    <title>Create a security plug-in</title>

    <section id="writsecs">
      <title>Writing your own security service</title>

      <para>TODO.....</para>

      <para>For the implementation of your Authorization class, it is
      important to assure that the instances are serializeable and can also be
      deserialized. This is important to allow the caching to be clustered.
      While we don't require that the class implements Serializeable (thanks
      to the use of JBoss Serialization), you should think of the following
      points;</para>

      <itemizedlist>
        <listitem>
          <para>A no-arguments constructor is needed. This is allowed to be
          private (though that is not recommended, better make it protected if
          you don't want it to be generally used).</para>
        </listitem>

        <listitem>
          <para>If the authorization class is an inner class, do make it
          static if possible (otherwise the object has an implicit reference
          to the containing object, assuring it is included in the serialized
          state).</para>
        </listitem>

        <listitem>
          <para>If you need a logger, declare it as<programlisting>private final transient Logger log = LoggerFactory.getLogger(ClassName.class);</programlisting>to
          ensure that the logger is not serialized.</para>
        </listitem>

        <listitem>
          <para>You should not use auto-wiring. Instead, make sure your class
          implements <code>AuthorizationNeedsWiring</code>. This defined the
          <code>wire()</code> method which allows you to query the application
          context. Make sure you declare wired properties as transient. The
          <code>wire()</code> method is called when the authorization is
          attached to the SecurityContext (both for freshly created and
          deserialized instances).</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Integrating a Geomajas application in the ZK framework</title>

    <section>
      <title>Introduction</title>

      <para><ulink url="http://www.zkoss.org/">ZK</ulink> is a general purpose
      web framework that uses a server-side approach to create RIAs. The
      framework is Java-based and has a built-in mechanism to synchronize
      presentation state between client and server based on Ajax requests.
      Geomajas on the other hand is a GIS application framework based on GWT.
      GWT compiles java code to javascript and makes use of Ajax requests and
      a custom serialization mechanism to communicate with the server. There
      is no presentation state on the server and the client is functionally a
      thick client (as opposed to ZK).</para>

      <para>When mixing two frameworks it is generally advisable to wrap UI
      components of the foreign framework in such a way that they become
      indistinguishable from native UI components. This technique is actually
      mandatory for frameworks that take complete control over the HTML
      layout, like ZK. While there is not mcuh information available with
      respect to GWT, we have successfully followed the same technique that
      was used in ZK for Google Maps and JQuery.</para>
    </section>

    <section>
      <title>Integrating GWT widgets in ZK</title>

      <para>ZK allows the creation of custom components. In the 5.0.3 version,
      we need to prepare four types of files in order to create a
      component:</para>

      <itemizedlist>
        <listitem>
          <para>The lang-addon.xml file: Registers the new ZK component</para>
        </listitem>

        <listitem>
          <para>The component file (*.java): Server-side Java component
          object</para>
        </listitem>

        <listitem>
          <para>The widget file (*.js): Client-side JavaScript widget object
          (there is a one-to-one correspondance with the server
          component)</para>
        </listitem>

        <listitem>
          <para>The template files (*.dsp): (optional) molds to generate the
          HTML representation of the client part. Alternatively, a redraw
          method can be defined in the .js file.</para>
        </listitem>

        <listitem>
          <para>The zk.wpd file : Widget Package Descriptor (WPD) file
          describing the information of a package, such as its widget classes
          and external JavaScript files</para>
        </listitem>
      </itemizedlist>

      <para>To represent a GWT widget as a ZK component, a wrapper has to be
      created around the GWT widget. Although both frameworks are Java-based,
      there is no communication possible between both as GWT is client-side
      while ZK is server-side. This means that any wrapping has to be done by
      providing mutual hooks or callback functions in the javascript
      files.</para>

      <para>We will now give a more detailed overview of each file and its
      functionalities.</para>

      <para>The lang-addon.xml file is located in the classpath at
      /metainfo/zk/lang-addon.xml. In the lang-addon.xml file, the tag name of
      the new component is determined and the class name of the component and
      its corresponding widget:</para>

      <para><programlisting>&lt;language-addon&gt;
 &lt;addon-name&gt;geomajasmap&lt;/addon-name&gt;
 &lt;language-name&gt;xul/html&lt;/language-name&gt;
 &lt;component&gt;
  &lt;component-name&gt;geomajasmap&lt;/component-name&gt;  &lt;!-- this is the tag name --&gt;
  &lt;component-class&gt;com.xxx.GeomajasComponent&lt;/component-class&gt; &lt;!-- this is the full java class name --&gt;
  &lt;widget-class&gt;com.xxx.GeomajasWidget&lt;/widget-class&gt; &lt;!-- this the 'javascript class' name --&gt;
 &lt;/component&gt;
&lt;/language-addon&gt;</programlisting>The dsp file is optional and contains
      some javascript code to write out the HTML representation of the widget.
      We refer to the general <ulink
      url="http://books.zkoss.org/wiki/ZK_Component_Development_Essentials">ZK
      component development documentation</ulink> for more information on this
      file.</para>

      <para>The widget file defines a javascript class (or prototype) by
      extending the ZK widget class and is located in the classpath at
      web/js/com/xxx/GeomajasWidget.js. This file has the following
      content:</para>

      <para><programlisting>com.xxx.GeomajasWidget = zk.$extends(zk.Widget, {

 bind_ : function(evt) {
  this.$supers('bind_', arguments);
  // save a reference to this instance for later access by GWT
  this.$class._refs[this.uuid] = this;
 },

 unbind_ : function(evt) {
  this.$supers('unbind_', arguments);
 },

 redraw : function(out) {
  out.push('&lt;div', this.domAttrs_(), '&gt;&lt;/div&gt;');
 }
},  {
  // a static map of (id, instance) pairs, accessible by GWT
  _refs : {}
});</programlisting>The bind_() and unbind_() functions are called to after
      the widget is attached/detached to the dom tree. It seems a good choice
      to use the bind_() function as the initialization point of the wrapped
      GWT component. We would normally just create the GWT component at this
      point, but, because of a race condition between the ZK and GWT
      javascript loads, the GWT part may not be loaded yet. For that reason,
      we register a reference to the component in a static map and let this
      reference be picked up and initialized later on by the GWT code. The
      redraw() function simply creates an empty div with the correct
      id.</para>

      <para>The component file is a server side java class that extends the ZK
      XulElement class. Its main purpose is to act as a relay to the client
      part:</para>

      <para><programlisting>
public class GeomajasComponent extends XulElement {

 static {
  addClientEvent(GeomajasComponent.class, FeatureSelectedEvent.NAME, CE_IMPORTANT);
  ...
 }

 private String featureId;
 
 // server-to-client communication
 public void panToFeature(String featureId) {
  if (featureId != null &amp;&amp; !featureId.equals(this.featureId)) {
   this.featureId = featureId;
   smartUpdate("panToFeature", featureId); // send the update to the client
  }
 }

 @Override
 protected void renderProperties(ContentRenderer renderer) throws java.io.IOException {
  super.renderProperties(renderer);
  render(renderer, "panToFeature", featureId); // mandatory by ZK for batch updates
 }

 // client-to-server communication
 @Override
 public void service(AuRequest request, boolean everError) {
  final String cmd = request.getCommand();

  if (cmd.equals(FeatureDeselectedEvent.NAME)) {
   FeatureDeselectedEvent evt = FeatureDeselectedEvent.getEvent(request);
   Events.postEvent(evt); // post as an application-wide event
  } ...
  else {
   super.service(request, everError);
  }
 }

}
</programlisting>The panToFeature() method can be called from other ZK server
      components to let the map pan to a certain feature. The command is
      forwarded to the client by using the smartUpdate() method. The way ZK
      communicates with its client objects or widgets is by invoking setters
      on the client object. This makes sense for a light weight client object
      but is rather awkward from a GWT viewpoint. In this case, the
      setPanToFeature() function will be called on the GeomajasWidget
      javascript object. We will now make sure that this function directly
      calls an equivalent function on the GWT component:</para>

      <para><programlisting>
public class GeomajasMapWrapper {

 private JavaScriptObject object;
 
 private MapWidget map;

 public GeomajasMapWrapper(JavaScriptObject object, String id) {
  this.object = object;
  ...  // create and attach the map to DOM element with the specified id (using BasicWidget.setHtmlElement() for SmartGWT)
  initProperties(object);
 }

 public void panToFeature(String args) {
      // pan to feature implementation
 }

 public native void initProperties(JavaScriptObject object) /*-{
  var _this = this;
  object.setPanToFeature = function (featureId) {
   _this.@com.xxx.client.zk.GeomajasMapWrapper::panToFeature(Ljava/lang/String;)(featureId);
  };
 }-*/;

 public native void forwardFeatureSelected(JavaScriptObject object, String featureId) /*-{
  object.fire("onFeatureSelected",{"featureId" : featureId});
 }-*/;

 ...

 public static native void init() /*-{
  var maps = $wnd.com.xxx.GeomajasWidget._refs;
  for(var uuid in maps) {
   var cmp = maps[uuid];
   @com.xxx.client.zk.GeomajasMapWrapper::new(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;)(cmp, cmp.uuid);
  }

  // override the bind function in case GWT was loaded first !
  $wnd.com.keyobs.urbagis.GeomajasWidget.prototype.bind_ = function(evt) {
   this.$supers('bind_', arguments);
   @com.xxx.client.zk.GeomajasMapWrapper::new(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;)(this, this.uuid);
  };
 }-*/;
</programlisting>There are multiple JSNI methods in this wrapper class to
      communicate between the GWT and ZK worlds:</para>

      <para>The init() method should be called once. It initializes registered
      references in the GeomajasWidget class by calling the constructor of the
      GeomajasWrapper class itself. It then overrides the bind_() function to
      make sure that any calls to bind_() will have the same effect. This is
      important in case the GWT part was loaded before bind_() was called by
      the ZK framework.</para>

      <para>The initProperties() method will add a relay-function to the ZK
      widget with signature setPanToFeature(). It will forward the
      smartUpdate() from the ZK framework to the GWT method panToFeature() of
      our GWT class.</para>

      <para>The forwardFeatureSelected() method will fire an event from the ZK
      client to the ZK server. This method can be called when a feature is
      selected on the map.</para>
    </section>

    <section>
      <title>Bidirectional communication between the two frameworks</title>

      <para>Communicating from GWT to ZK takes the following steps : GWT event
      -&gt; JSNI call to ZK javascript -&gt; server command -&gt; ZK component
      -&gt; ZK event.</para>

      <para>The following code parts are required:</para>

      <itemizedlist>
        <listitem>
          <para>add event listener to GWT widget</para>
        </listitem>

        <listitem>
          <para>add JSNI call to GWT widget to forward the event</para>
        </listitem>

        <listitem>
          <para>add javascript function to ZK javascript to send the ZK
          command</para>
        </listitem>

        <listitem>
          <para>process the ZK command in the ZK component</para>
        </listitem>

        <listitem>
          <para>fire application event in ZK component</para>
        </listitem>
      </itemizedlist>

      <para>Communicating from ZK to GWT takes the following steps : ZK java
      call -&gt; ZK component -&gt; smartupdate -&gt; ZK JSNI callback -&gt;
      GWT call.</para>

      <para>The following code parts are required:</para>

      <itemizedlist>
        <listitem>
          <para>add event listener to ZK component</para>
        </listitem>

        <listitem>
          <para>add update method to ZK component</para>
        </listitem>

        <listitem>
          <para>add ZK callback function to GWT component</para>
        </listitem>

        <listitem>
          <para>process the ZK callback in the GWT component</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Bidirectional communication between ZK and GWT</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/zk-gwt.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>
</part>
