<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
  ~ This file is part of Geomajas, a component framework for building
  ~ rich Internet applications (RIA) with sophisticated capabilities for the
  ~ display, analysis and management of geographic information.
  ~ It is a building block that allows developers to add maps
  ~ and other geographic data capabilities to their web applications.
  ~
  ~ Copyright 2008-2010 Geosparc, http://www.geosparc.com, Belgium
  ~
  ~ This program is free software: you can redistribute it and/or modify
  ~ it under the terms of the GNU Affero General Public License as
  ~ published by the Free Software Foundation, either version 3 of the
  ~ License, or (at your option) any later version.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~ GNU Affero General Public License for more details.
  ~
  ~ You should have received a copy of the GNU Affero General Public License
  ~ along with this program.  If not, see <http://www.gnu.org/licenses/>.
  -->
<part id="part-gwt-face">
  <title>GWT face</title>

  <chapter>
    <title>GWT face architecture</title>

    <section>
      <title>Client-server communication</title>

      <para>Client-server communication in Geomajas is executed through a
      series of commands instantiated on the client and executed by the
      server. In the GWT face, all such commands are executed by
      <code>org.geomajas.gwt.client.command.GwtCommandDispatcher</code>. This
      class has one single method for instantiating such commands and handling
      the result: the <code>execute</code> method.</para>

      <para>The command, required by the execute method
      (<code>GwtCommand</code>), is in fact a wrapper around a
      <code>CommandRequest</code> object (see <link
      linkend="architecture-command">architecture</link>), wherein the name of
      the requested command is found. Each command expects a certain
      implementation of the <code>CommandRequest</code> and
      <code>CommandResponse</code> objects. Note that these request and
      response objects must also be known server-side, and thus will not be
      packaged within the GWT client packages. As a second parameter for the
      execute method, a <code>CommandCallback</code> object is required that
      will execute it's only method on a successful return of a
      command.</para>

      <para>The execution will immediately return a <code>Deferred</code>
      object, that can be used to add more callback methods, both for
      successful as for an erroneous result of the command's execution.</para>

      <xi:include href="../listing/GwtCommandExecution.xml"
                  xmlns:xi="http://www.w3.org/2001/XInclude" />
    </section>

    <section>
      <title>The map's model</title>

      <para>As with any GIS framework or application, the most crucial of all
      entities is the Map. A map is represented by the
      <code>org.geomajas.gwt.client.widget.<code>MapWidget</code></code>, but
      is set up using the standard model-view-controller paradigm. The widget
      is the actual view of a map, with <code>Painter</code> objects building
      the display. The user interaction is handled using controllers,
      represented by the <code>GraphicsController</code> interface. The third
      aspect, the model, is represented by the
      <code>org.geomajas.gwt.client.map.<code>MapModel</code></code>.</para>

      <section>
        <title>MapModel</title>

        <para>The definition of the model behind a map
        (<code>org.geomajas.gwt.client.map.<code>MapModel</code></code>). This
        object stores all map metadata and layers, and has an extensive
        arsenal of methods to operate on the layers and the features.</para>

        <para>Another aspect of the <code>MapModel</code> is the list of
        events that it fires. Handlers for the following events can be added
        to the <code>MapModel</code>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>MapModelEvent</emphasis>: this event is fired when
            the <code>MapModel</code> has been properly initialized. When a
            <code>MapWidget</code> is added to the HTML page, it automatically
            triggers an initialization method. This will ask the server to
            supply it with the correct metadata, so that the
            <code>MapModel</code> can actually build it's layers, etc. Once
            this initialization process is done, a <code>MapModelEvent</code>
            will be fired. Add a
            <code>org.geomajas.gwt.client.map.event.MapModelHandler</code> to
            use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>FeatureSelectedEvent</emphasis>: this event is
            fired every time a feature within one of this model's vector
            layers is selected. Add a
            <code>org.geomajas.gwt.client.map.event.FeatureSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>FeatureDeselectedEvent</emphasis>: this event is
            fired every time a feature within one of this model's vector
            layers is deselected. Add a
            <code>org.geomajas.gwt.client.map.event.FeatureSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>LayerSelectedEvent</emphasis>: this event is fired
            every time a layer within this model is selected. Add a
            <code>org.geomajas.gwt.client.map.event.LayerSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>LayerDeselectedEvent</emphasis>: this event is
            fired every time a layer within this model is deselected. Add a
            <code>org.geomajas.gwt.client.map.event.LayerSelectionHandler</code>
            to use this.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>MapView</title>

        <para>Part of a map is this
        <code>org.geomajas.gwt.client.map.MapView</code> object, which
        determines and influences what area is currently visible. Internally
        the <code>MapView</code> has a <code>Camera</code> object that you can
        think of a a satellite that floats above the map. This
        <code>Camera</code> floats at a certain height, on a certain position,
        and this will determine what part of the map is shown.</para>

        <para>The map contains several coordinate spaces.</para>

        <para><itemizedlist>
            <listitem>
              <para>world space : coordinates use the crs of the map.</para>
            </listitem>

            <listitem>
              <para>screen space : pixel coordinates.</para>
            </listitem>

            <listitem>
              <para>pan space : objects have already been scaled to the map's
              current scale, but the translation transformation still needs to
              occur. This is space is used for rendering the layers and should
              normally not be used for other purposes.</para>
            </listitem>
          </itemizedlist>The <code>MapView</code> provides conversions of
        coordinates between these spaces. Inside the MapView is a transformer
        (<code>org.geomajas.gwt.client.spatial.WorldViewTransformer</code>)
        that is able to transform coordinates, geometries and bounding boxes
        from screen space to world space and back.</para>
      </section>

      <section>
        <title>Workflow</title>

        <para>A work flow in the GWT face determines how editing should be
        handled. It can consist of several steps, called activities. When a
        work flow finishes, changes will typically be persisted. The package
        is: <code>org.geomajas.gwt.client.map.workflow</code></para>

        <figure>
          <title>Workflow API</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_workflow.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para><emphasis role="bold">Activity:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>execute</emphasis>: this method is called by the
            encompassing processor to execute the activity.</para>
          </listitem>

          <listitem>
            <para><emphasis>getErrorHandler</emphasis>: get the error handler
            that is specifically tuned for the activity.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowErrorHandler:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>handleError</emphasis>: Executed when an activity
            throws an exception during execution. The
            <code>WorkflowProcessor</code> must make sure this method is
            executed.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowContext:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>stopProcess</emphasis>: informs the
            <code>WorkflowProcessor</code> to stop the processing of
            activities. It is the <code>WorkflowProcessors</code>
            responsibility to ask for this, and execute no more activities
            when "<code>true</code>" is returned.</para>
          </listitem>

          <listitem>
            <para><emphasis>setSeedData</emphasis>: provide some seed
            information to the context. This is usually provided at the time
            of work flow kickoff.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowProcessor:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>supports</emphasis>: ensure that each activity
            configured in this process is supported. This method should be
            called by implemented subclasses for each activity that is part of
            the process.</para>
          </listitem>

          <listitem>
            <para><emphasis>doActivities</emphasis>: this method kicks off the
            processing of work flow activities.</para>
          </listitem>

          <listitem>
            <para><emphasis>setActivities</emphasis>: set a list of activities
            to be executed in the process. This would also be a good time to
            check if activities are supported.</para>
          </listitem>

          <listitem>
            <para><emphasis>setDefaultErrorHandler</emphasis>: set a default
            error handler, which is invoked when the activity throws an
            uncaught exception.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Selection of features</title>

        <para>A feature in a vector layer has the possibility to be selected.
        Selection usually changes the colour of the feature on the map or in a
        table to make it stand out. The actual selecting handled by the
        <code>MapModel</code>. In the map model, the selected features are
        stored. After all, it is possible that by moving away from a certain
        area, the selected features are no longer in sight, and perhaps no
        longer in the client layer-cache. Still their contents may be needed
        for specific tasks.</para>

        <para>The <code>MapModel</code> fires events when changes in selection
        occur. It will fire either <code>FeatureSelectedEvent</code> or
        <code>FeatureDeselectedEvent</code>. The <code>MapModel</code>
        implements the <code>HasFeatureSelectionHandler</code> interface so
        other components can register with the <code>MapModel</code> as
        <code>FeatureSelectionHandler</code>. For example the
        <code>MapWidget</code> will register itself as a handler to know when
        a feature is selected or deselected and redraw it accordingly.</para>

        <figure>
          <title>Selection events and handlers</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_selection.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When writing code that needs to react upon the selection of
        features, implement the <code>FeatureSelectionHandler</code>
        interface, and register yourself with the
        <code>MapModel</code>.</para>

        <para><note>
            <para>Individual vector layers can also fire selection events.
            Actually the <code>MapModel</code> propagates the events from the
            individual vector layers, so that the user need only install his
            handlers in one place.</para>
          </note></para>
      </section>
    </section>

    <section>
      <title>The spatial package</title>

      <para>The spatial package (<code>org.geomajas.gwt.client.spatial</code>)
      contains a collection of math and geometry related classes and utilities
      to provide all the client-side calculations one should need. If really
      complex calculations need to be performed, it's best to let the server
      (probably using JTS) handle it anyway. The root of the package contains
      the general mathematical definitions of a Vector, Matrix, LineSegment,
      and so on. It also provides a general math library and the
      <code>org.geomajas.gwt.client.spatial.WorldViewTransformer</code>.</para>

      <para>The <code>WorldViewTransformer</code> in particular can be a very
      valuable tool. It allows you to transform coordinates, bounding boxes
      and geometries between the 3 pre-defined spaces (world, view,
      pan).</para>

      <section>
        <title>Geometry definitions</title>

        <para>All <code>Geometry</code> definitions in the GWT face are based
        on geometries from JTS, the Java Topology Suite, and the OGC simple
        feature specification. The classes can be found in the
        <code>org.geomajas.gwt.client.spatial.geometry</code> package.
        Supported geometries are:</para>

        <itemizedlist>
          <listitem>
            <para><code>Point</code>: a geometry representation of a single
            coordinate.</para>
          </listitem>

          <listitem>
            <para><code>MultiPoint</code>: a geometry containing multiple
            <code>Point</code> geometries.</para>
          </listitem>

          <listitem>
            <para><code>LineString</code>: a list of connected coordinates.
            Sometimes also called a polyline.</para>
          </listitem>

          <listitem>
            <para><code>LinearRing</code>: an extension of the
            <code>LineString</code> geometry that expects the last coordinate
            to be equal to the first coordinate. In other words, a
            <code>LinearRing</code> is a closed
            <code>LineString</code>.</para>
          </listitem>

          <listitem>
            <para><code>MultiLineString</code>: a geometry containing multiple
            <code>LineString</code> geometries.</para>
          </listitem>

          <listitem>
            <para><code>Polygon</code>: a <code>Polygon</code> is a two-part
            geometry, consisting of an exterior <code>LinearRing</code> and a
            list of interior <code>LinearRings</code>. The exterior
            <code>LinearRing</code>, also called the shell, is the outer hull
            of the geometry, while the interior rings can be seen as holes in
            the exterior ring's surface area.</para>
          </listitem>

          <listitem>
            <para><code>MultiPolygon</code>: a geometry containing multiple
            <code>Polygon</code> geometries.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Editing geometries</title>

        <para>The <code>Geometry</code> implementations themselves do not have
        any setters methods. Instead the editing of geometries is done through
        a series of operations, all implementing the <code>
            <code>org.geomajas.gwt.client.spatial.geometry.operation.GeometryOperation</code>
          </code> interface. This interface consists of only one method,
        accepting a geometry, and returning the result as a new
        geometry.</para>

        <para>Geometries have no public constructors, so the creation of new
        geometries is done using a factory,
        <code>org.geomajas.gwt.client.spatial.geometry.GeometryFactory</code>.
        A <code>GeometryFactory</code> can be created using a spatial
        reference id and a certain precision, but it can also be retrieved
        from any geometry instance (where srid and precision are automatically
        correct).</para>

        <para><code>GeometryOperation</code> interface:</para>

        <xi:include href="../listing/GeometryOperation.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />
      </section>

      <section>
        <title>Snapping</title>

        <para>Snapping in Geomajas, is handled by a single manager class
        called the
        <code>org.geomajas.gwt.client.spatial.snapping.Snapper</code>. It is
        the main handler for snapping to coordinates. It supports different
        modes of operation and different algorithms for the actual snapping.
        The different algorithms to use are defined in the vector layer
        configuration files, while the modes are defined by the different
        implementations of the <code>SnappingMode</code> class. Let us first
        start with the different modes:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>ALL_GEOMETRIES_EQUAL</emphasis>: this snapping
            mode considers all geometries equal when it comes to determining
            where to snap to. Depending on the snapping algorithm used, it
            will simply consider all nearby geometries.</para>
          </listitem>

          <listitem>
            <para><emphasis>PRIORITY_TO_INTERSECTING_GEOMETRIES</emphasis>:
            this snapping mode tries to snap to intersecting geometries before
            trying the general approach. When searching a snapping coordinate
            for a given point, this mode will first search for intersecting
            geometries and try to get a snap to that. If no snapping point can
            be found, it will consider all nearby geometries (like
            ALL_GEOMETRIES_EQUAL).</para>
          </listitem>
        </itemizedlist>

        <para>The snapping rules themselves are defined in the server-side
        configuration. Each vector layer can have many snapping rules. For
        each rule, 3 fields must be filled:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>layer</emphasis>: the target layer to snap
            to.</para>
          </listitem>

          <listitem>
            <para><emphasis>distance</emphasis>: the distance over which to
            snap. This distance must be expressed in the map's coordinate
            system.</para>
          </listitem>

          <listitem>
            <para><emphasis>type</emphasis>: the snapping algorithm to use. At
            the moment 2 types of snapping algorithms are supported: to the
            nearest point (type=1), and to the nearest edge (type=2). For
            nearest point snapping can only occur to any coordinate which is a
            end-point for a geometry, for nearest edge that can be any
            coordinate on the edge of the geometry. Needless to say, the
            nearest edge requires more calculating power than the nearest
            point.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Snapping on the map</emphasis></para>

        <para>When a <code>GraphicsController</code> for the map needs to use
        snapping (i.e. editing controllers), they should extend the
        <code>org.geomajas.gwt.client.controller.AbstractSnappingController</code>
        class. This class extends the <code>GraphicsController</code> class
        (the base class for all Geomajas map controllers), and overwrites the
        <code>getScreenPosition</code> and <code>getWorldPosition</code>
        methods to assure the points are snapped. The
        <code>AbstractSnappingController</code> also supports the on-the-fly
        activation and deactivation of snapping.</para>
      </section>
    </section>

    <section>
      <title id="graphics">Graphics &amp; rendering</title>

      <para>In the GWT face, the main <code>render</code> method can be found
      in <code>MapWidget</code>. The render method requires three parameters,
      a paintable object, a target group to paint in and a status. The
      paintable object is the actual object that needs to be painted. The
      target group
      (<code>org.geomajas.gwt.client.widget.MapWidget.RenderGroup</code>)
      specifies where in the DOM to draw. The usual choices here are the
      SCREEN or the WORLD groups. The rendering status
      (<code>org.geomajas.gwt.client.widget.MapWidget.RenderStatus</code>)
      determines what drawing action to take.</para>

      <para><emphasis role="bold">RenderStatus</emphasis></para>

      <para>The render status can be one of the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>ALL</emphasis>: completely render or re-render the
          paintable object. If the paintable object contains other paintable
          object, go through them recursively (a map will paint layers, who in
          turn will paint tiles, ...)</para>
        </listitem>

        <listitem>
          <para><emphasis>UPDATE</emphasis>: update the paintable object in
          question, but do not update recursively.</para>
        </listitem>

        <listitem>
          <para><emphasis>DELETE</emphasis>: delete the paintable object from
          the map.</para>
        </listitem>
      </itemizedlist>

      <para>While rendering, the map uses a visitor to visit the paintable
      objects recursively and search for painters for each object or
      sub-object. The "ALL" status will paint recursively while the "UPDATE"
      status will not go deeper then the given paintable object. Of course, if
      a given paintable object has no recursive paintable objects, then the
      difference between "ALL" and "UPDATE" is irrelevant.</para>

      <para><emphasis role="bold">RenderGroup</emphasis></para>

      <para>The rendergroup that needs to be specified when calling the map's
      render method, represents the logical place on the map to draw the
      paintable object. There are four choices, each having a huge
      impact.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>WORLD</emphasis>: drawing should be done in world
          coordinates. World coordinates means that the map coordinate system
          should be used. The advantage of rendering objects in the world
          group, is that when the user moves the map around, the objects will
          move with it.</para>
        </listitem>

        <listitem>
          <para><emphasis>SCREEN</emphasis>: drawing should be done in screen
          coordinates. Screen coordinates are expressed in pixels, starting
          from the top left corner of the map. When rendering objects in the
          screen group they will always appear at a fixed position, even when
          the user moves the map about.</para>
        </listitem>

        <listitem>
          <para><emphasis>RASTER</emphasis>: drawing should be done in pan
          coordinates. All raster layers are drawn in this group. In essence
          this means that the coordinates are expected to have been scaled for
          the current scale before drawing, and that only the translation
          still needs to occur. For advanced use only.</para>
        </listitem>

        <listitem>
          <para><emphasis>VECTOR</emphasis>: drawing should be done in pan
          coordinates. All vector layers, their selection and their labels are
          drawn in this group. In essence this means that the coordinates are
          expected to have been scaled for the current scale before drawing,
          and that only the translation still needs to occur. For advanced use
          only.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>GFX interfaces</title>

        <para>As will be explained in more detail in the "rendering manual",
        there are 2 ways of drawing on the map: directly using some rendering
        context, or indirectly using <code>Paintable</code> objects,
        <code>Painter</code>s and the <code>MapWidget</code>'s
        <code>render</code> method (as explained above). When using the direct
        approach, one has to call the methods of one of the different
        rendering contexts. A <code>MapWidget</code> contains a
        <code>MapContext</code> implementation, which in turn contains 3
        different contexts:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>MenuContext</emphasis>: used for keeping details
            about right mouse clicks. Not used for rendering.</para>
          </listitem>

          <listitem>
            <para><emphasis>ImageContext</emphasis>: used for rendering images
            in HTML. All raster layers use this context.</para>
          </listitem>

          <listitem>
            <para><emphasis>GraphicsContext</emphasis>: the main vector
            graphics renderer. Can also render images, but uses SVG or VML to
            do so. When rendering shapes, circles, rectangle, etc. you will
            always be using this context.</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Main context interfaces from the GFX package</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_gfx_context.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The <code>GraphicsContext</code> is the main vector drawing
        context. It has two implementations: one for SVG and one for
        VML.</para>

        <figure id="graphicscontext">
          <title>GraphicsContext interface</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_graphicscontext.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Every object that appears on a Geomajas map, has to implement
        the <code>Paintable</code> interface. This interface marks types of
        objects that can be painted. For each type/class of paintable object,
        an accompanying <code>Painter</code> must be defined as well. The
        painter will ultimately decide exactly how a paintable object should
        be rendered. The painter will render objects using it's
        <code>paint</code> method, or delete objects from the map using it's
        <code>deleteShape</code> method.</para>

        <figure>
          <title>General graphics interfaces</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="../images/gwtface_gfx.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <itemizedlist>
          <listitem>
            <para><emphasis>GraphicsContext</emphasis>: this is the basic
            drawing interface. Different implementations will draw in
            different technologies (i.e. <code>SvgGraphicsContext</code> and
            <code>VmlGraphicsContext</code>). The whole idea of this
            <code>GraphicsContext</code> and the painters, was inspired by the
            Java AWT library. This context will draw basic shapes, according
            to their id. Since we are using web technologies, all
            implementations (be they SVG or VML) will use DOM elements to
            create their drawings. Each DOM element in the
            <code>GraphicsContext</code> DOM tree should have an id and a
            parent. This combination of id and parent can later be used to
            update or delete the object.</para>

            <para>In essence, the drawing methods will result in changes in
            the visuals of the map, and the painters that will call these
            methods.</para>
          </listitem>

          <listitem>
            <para><emphasis>Paintable</emphasis>: the basic definition of an
            object that can be painted onto the map. For each
            <code>Paintable</code> class, an accompanying <code>Painter</code>
            class must be defined. The <code>Paintable</code> interface has
            only two methods. The <code>getId</code> method returns the
            <code>Paintable</code> objects id, which is it's key in the DOM
            tree within the parent group. While the accept method will be
            traversed by the <code>PainterVisitor</code>, and is used to have
            the object passed to the correct <code>Painter</code>, which will
            draw the object.</para>
          </listitem>

          <listitem>
            <para><emphasis>WorldPaintable</emphasis>: extension of the
            <code>Paintable</code> interface for objects that support being
            rendered in world space. This means that it should be possible to
            transform the object's geometry/location/coordinate/bbox.</para>
          </listitem>

          <listitem>
            <para><emphasis>Painter</emphasis>: A <code>Painter</code> knows
            how to paint a specific kind of <code>Paintable</code> object.
            Exactly what class of <code>Paintable</code> objects it can draw,
            must be made clear by it's <code>getPaintableClassName</code>
            method. Furthermore, the <code>Painter</code> has two methods to
            paint or remove <code>Paintable</code> objects on or from the
            given <code>GraphicsContext</code>. Basically, the
            <code>Painter</code> translates the fields and parameters of the
            <code>Paintable</code> object into calls to the
            <code>GraphicsContext</code>.</para>
          </listitem>

          <listitem>
            <para><emphasis>PainterVisitor</emphasis>: Geomajas uses a visitor
            algorithm for it's client side rendering process. The
            <code>MapWidget</code> uses a <code>PainterVisitor</code> to
            recursively traverse the tree of <code>Paintable</code> objects,
            calling the <code>accept</code> method on each node.</para>

            <para>Of course this recursive system of searching for the correct
            <code>Painter</code>, can only work when the
            <code>PainterVisitor</code> has all the necessary painters
            registered. When registering a <code>Painter</code> with the
            <code>MapWidget</code>, it will actually pass it along to this
            <code>PainterVisitor</code> instance.</para>

            <para>An example of the recursive painting, can be found in the
            <code>MapModel</code>, which calls the <code>accept</code> methods
            of it's layers, which call the <code>accept</code> methods of the
            visible tiles, which contain features.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Rendering manual</title>

        <para>There are two ways to render objects onto the map. One uses
        <code>Paintable</code> objects and <code>Painter</code>s, the other is
        by using the <code>GraphicsContext</code> directly. There are still
        some general notions that one must know before attempting to draw on
        the map. Since HTML, SVG and VML are all markup languages which use a
        DOM tree as basic model, rendering basically is the adding and
        removing of nodes within this tree. As parent nodes have styling
        information or other attributes that reflect their child nodes, it is
        very important to add nodes to the correct parent when drawing.</para>

        <para>The <link linkend="graphicscontext">GraphicsContext</link>
        reflects this, by requiring a parent object as first parameters in all
        drawing methods. Associated with every node is an object that
        represents it. Given this object, the <code>GraphicsContext</code> can
        find the correct node. When using the <code>GraphicsContext</code>
        directly, it is important to be aware of the necessity of using the
        correct parent group when drawing.</para>

        <section>
          <title>The simple approach - indirect drawing</title>

          <section>
            <title>Drawing in screen space</title>

            <para>This approach uses <code>MapWidget</code>'s render method,
            which requires three parameters: a <code>Paintable</code> object,
            a target <code>RenderGroup</code>, and a
            <code>RenderStatus</code>. If you are unfamiliar with these, visit
            the <link linkend="graphics">beginning of this chapter</link> for
            a detailed description.</para>

            <para>Let us start with an example, where we draw a rectangle in
            screen space (=pixel coordinates). The code would look something
            like this:</para>

            <programlisting>Rectangle rectangle = new Rectangle("myRectangle");
rectangle.setBounds(new Bbox(10, 10, 200, 200));
rectangle.setStyle(new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2));

map.render(rectangle, RenderGroup.SCREEN, RenderStatus.ALL);</programlisting>

            <para>This code snippet would draw a rectangle (which implements
            <code>Paintable</code>), called "myRectangle" in screen space (10
            pixels from the top, 10 pixels from the left, and with a width and
            height of both 200), using the defined style (red interior with a
            blue border). To delete the rectangle again, you would have to do
            something like this:</para>

            <programlisting>map.render(rectangle, RenderGroup.SCREEN, RenderStatus.DELETE);</programlisting>
          </section>

          <section>
            <title>Drawing in world space</title>

            <para>Remember that there was also an extension of the
            <code><code>Paintable</code></code> interface, designed for
            rendering objects in world space. Rendering in world space means
            that objects are drawn in the coordinate system of the map. This
            also means that when the user moves about on the map, the object
            will move with it (keeping the same location in map coordinates).
            Only objects that implement the <code>WorldPaintable</code>
            interface can be drawn in world space.</para>

            <para>Let us, for the next example, assume that the map has been
            defined using EPSG:4326 (lonlat) as coordinate system, and we
            would apply the following code snippet:</para>

            <programlisting>Rectangle rectangle = new Rectangle("myRectangle");
rectangle.setBounds(new Bbox(-60, -60, 120, 120));
rectangle.setStyle(new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2));

// Register the rectangle to the map, so that it gets redrawn
// automatically when the user navigates on the map.
map.registerWorldPaintable(rectangle);</programlisting>

            <para>Starting from -60, -60 and using a width and height of 120,
            we would have a rectangle that encompasses a huge part of the
            world. Note that drawing objects in world space requires you to
            register them with the map. This is necessary to have the map
            automatically update the object's position when the user
            navigates. When registering the <code>WorldPaintable</code>
            rectangle, it is automatically drawn on the map.</para>
          </section>
        </section>

        <section>
          <title>The advanced approach - using the GraphicsContext
          directly</title>

          <para>When more flexibility is required from the rendering system,
          the map's render method might sometimes not be enough. If for
          example we want to render more than one object within a specific
          parent group. The following code snippet shows how to render a
          specific parent in screen space and then render a circle within this
          parent group:</para>

          <programlisting>// Create a parent group within screen space:
Composite parent = new Composite("myParent");
map.getVectorContext().drawGroup(map.getGroup(RenderGroup.SCREEN), parent);

// Draw a circle at (20, 20) with radius 10 pixels within parent group:
Coordinate pos = new Coordinate(20, 20);
ShapeStyle style = new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2);
map.getVectorContext().drawCircle(parent, "myCircle", pos, 10, style);</programlisting>

          <para>Since no special parameters are added to the "myParent" node,
          the circle is drawn as if it were in the screen group itself. But
          thanks to the extra parent group, we now have the ability for apply
          specific styling or transformations on that parent group, and thus
          altering all children within it. Let us for example move the circle
          100 pixels to the right:</para>

          <programlisting>// Translate the parent group 100 pixels to the right:
Matrix m = new Matrix(1, 0, 0, 1, 100, 0);
map.getVectorContext().drawGroup(map.getGroup(RenderGroup.SCREEN), parent, m);</programlisting>

          <warning>
            <para>Do not try to render objects in world space by directly
            accessing the <code>GraphicsContext</code>. Behind the screens of
            the <code>MapWidget</code>, the world space objects are actually
            transformed and rendered in <emphasis>vector</emphasis> space.
            This is done to avoid scaling in the DOM tree (as this is not
            possible cross browsers).</para>
          </warning>
        </section>
      </section>
    </section>

    <section>
      <title id="interaction">User interaction</title>

      <para>This section covers the many interfaces regarding buttons, menu
      items and such that make up the user interface. The specific Geomajas
      widgets (i.e. <code>LayerTree</code>) require a specific way of doing
      things. We will cover the interfaces for the <code>Toolbar</code>,
      <code>LayerTree</code>, map controllers and context menus.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Toolbar</emphasis>: the tool bar has two types of
          default actions one can add to it (there is always the
          <code>addChild</code> method, which can add any widget, but we are
          now talking about Geomajas specific possibilities): the
          <code>ToolbarAction</code> and the <code>ToolbarModalAction</code>.
          The <code>ToolbarAction</code> is used for actions that need
          immediate response upon clicking, while the
          <code>ToolbarModalAction</code> is used for enabling or disabling a
          certain state.</para>
        </listitem>

        <listitem>
          <para><emphasis>LayerTree</emphasis>: the <code>LayerTree</code> has
          the possibility to add buttons to it's tool bar that usually act
          upon the selected layer within the <code>LayerTree</code>. Again two
          types of actions can be added: the <code>LayerTreeAction</code> and
          the <code>LayerTreeModalAction</code>. The same difference as with
          the tool bar applies: the <code>LayerTreeAction</code> is a base
          abstract class for actions that execute immediately upon clicking,
          while the <code>LayerTreeModalAction</code> is used for enabling or
          disabling a certain state (for example: toggle the layer's
          visibility).</para>
        </listitem>

        <listitem>
          <para><emphasis>Menu</emphasis>: each item in a context menu should
          extend the <code>MenuAction</code> base class. This is your basic
          starting point for easily creating new menu items or context menu
          items.</para>
        </listitem>

        <listitem>
          <para><emphasis>Controllers on the map</emphasis>: for controllers
          listening to mouse events on a map, there is the
          <code>GraphicsController</code> interface, or an abstraction under
          the name of <code>AbstractGraphicsController</code>.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>For buttons in the <code>Toolbar</code> or
        <code>LayerTree</code> it is possible to add them to the
        <code>org.geomajas.gwt.client.action.toolbar.ToolbarRegistry</code> or
        <code>org.geomajas.gwt.client.action.layertree.LayerTreeRegistry</code>
        upon application startup (before <code>MapWidget</code>
        initialisation!). This allows you to add new buttons which can be
        included in the map configuration.</para>
      </note>

      <section>
        <title>Toolbar: ToolbarAction</title>

        <para>The <code>ToolbarAction</code> is your basic abstract class for
        building tool bar buttons that are executed immediately when clicked.
        The class implements the <code>ClickHandler</code> interface and
        requires your to specify an icon and a tool tip on creation.</para>

        <para><code>ToolbarAction</code> classes need to be registered in the
        <code>
            <code>ToolbarRegistry</code>
          </code> class. This allows you to get an instance of the widget to
        put in the tool bar. The tools which are part of the GWT face are
        statically defined in the class. Other tools can be added (or
        overwritten) at runtime before the map is initialised.</para>

        <para>When a <code>ToolbarAction</code> is configurable (XML
        configuration), it should implement the
        <code>ConfigurableAction</code> interface. This contains a
        "<code>configure()</code>" method which will be called for each of the
        parameters which are defined in the tool configuration.</para>

        <xi:include href="../listing/ToolbarAction.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />
      </section>

      <section>
        <title>Toolbar: ToolbarModalAction</title>

        <para>The <code>ToolbarModalAction</code> is the basic template for
        creating selectable tool bar buttons. Usually they enable and disable
        a certain state on the map when selected or deselected. Many of the
        implementations that come with Geomajas set a new controller on the
        map when they are selected.</para>

        <para>Note that only one of these <code>ToolbarModalActions</code> can
        be selected at any given time. In that sense they act as radio
        buttons.</para>

        <para><code>ToolbarModalAction</code> classes need to be registered in
        the <code>
            <code>ToolbarRegistry</code>
          </code> class. This allows you to get an instance of the widget to
        put in the tool bar. The tools which are always part of the GWT face
        are statically defined in the class. Other tools can be added (or
        overwritten) at runtime before the map is initialised.</para>

        <para>When a <code>ToolbarAction</code> is configurable, it should
        implement the <code>ConfigurableAction</code> interface. This contains
        a <code>configure()</code> method which will be called for each of the
        parameters which are defined in the tool configuration.</para>

        <xi:include href="../listing/ToolbarModalAction.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />
      </section>

      <section>
        <title>LayerTree: LayerTreeAction</title>

        <para>The <code>LayerTreeAction</code> is your basic abstract class
        for building layer tree buttons that are executed immediately when
        clicked. The <code>onClick()</code> method needs to be implemented and
        it also requires you to specify an icon, a tool tip and a disabled
        icon. Note that the <code>onClick()</code> has the selected layer
        within the <code>LayerTree</code> as a parameter.</para>

        <para><code>LayerTreeAction</code> classes need to be registered in
        the <code>LayerTreeRegistry</code> class. The tools which are always
        part of the GWT face are statically defined in the class. Other tools
        can be added (or overwritten) at runtime before the map is
        initialised.</para>

        <xi:include href="../listing/LayerTreeAction.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />
      </section>

      <section>
        <title>LayerTree: LayerTreeModalAction</title>

        <para>The <code>LayerTreeModalAction</code> is the basic template for
        creating selectable layer tree buttons. Usually they enable and
        disable a certain state for the selected layer within the layer tree
        (for example that layer's visibility).</para>

        <para><code>LayerTreeModalAction</code> classes need to be registered
        in the <code>LayerTreeRegistry</code> class. The tools which are
        always part of the GWT face are statically defined in the class. Other
        tools can be added (or overwritten) at runtime before the map is
        initialised.</para>

      </section>

      <section>
        <title>Menu: MenuAction</title>

        <para>To create menu items or context menu items, Geomajas provides a
        base which extends from SmartGWT's <code>MenuItem</code> class. It
        requires you to set a title and icon. It also implements the
        <code>ClickHandler</code> interface for defining the
        <code>onClick()</code> execution function.</para>

        <xi:include href="../listing/MenuAction.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />
      </section>

      <section>
        <title>Controllers on the map</title>

        <para>For interactive mouse listeners on the map there is a general
        interface, <code>GraphicsController</code>. To write a custom
        controller, you should always extend
        <code>AbstractGraphicsController</code>.</para>

        <caution>
          <para>The <code>GraphicsController</code> interface does NOT use
          SmartGWT events as they provide no way of getting the target DOM
          element from the mouse events. So the list of handlers that the
          <code>GraphicsController</code> extends, are all basic GWT event
          handlers. A separate widget (<code>GraphicsWidget</code>) has been
          created to catch the events, while the normal <code>MapWidget</code>
          (which encapsulates the <code>GraphicsWidget</code>) can still
          handle SmartGWT events.</para>
        </caution>

        <para>On top of all the event handling methods that come from the
        different handlers, the interface also has <code>onActivate()</code>
        and an <code>onDeactivate()</code> methods. The
        <code>onActivate()</code> is called before the controller is actually
        applied on the <code>GraphicsWidget</code>. This is usually used to
        apply a new context menu on the map and such. The
        <code>onDeactivate()</code> method is called when the controller is
        removed from the <code>GraphicsWidget</code>. This is usually used for
        cleaning up.</para>

        <xi:include href="../listing/GraphicsController.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />

        <para>You should never directly implement
        <code>GraphicsController</code> (not that it does not have the
        "<code>@UserImplemented</code>" annotation), you should always extend
        <code>AbstractGraphicsController</code>. This abstract class
        implements all methods as empty methods so you don't have to clutter
        your code with empty methods (often only a few of the mouse event
        methods are actually used). It also has some extra methods for return
        useful information for the mouse events, such as the position
        (expressed in screen coordinates) or the target DOM element.</para>

        <para>Small extract from the <code>AbstractGraphicsController</code>
        class:</para>

        <xi:include href="../listing/AbstractGraphicsController.xml"
                    xmlns:xi="http://www.w3.org/2001/XInclude" />

        <para>Now that you have your controller you can set it;</para>

        <programlisting>mapWidget.setController(new MeasureDistanceController(mapWidget));</programlisting>

        <note>
          <para>There are more abstractions than just the
          <code>AbstractGraphicsController</code>:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis>
                  <code>AbstractRectangleController</code>
                </emphasis>: abstract controller that handles drawing a
              rectangle by dragging the mouse on the map.</para>
            </listitem>

            <listitem>
              <para><emphasis>
                  <code>AbstractSnappingController</code>
                </emphasis>: abstract controller that allows snapping to be
              enabled and disabled. When enabled, the returned points when
              asking <code>getPosition()</code>, are snapped (depending on the
              configured snapping rules).</para>
            </listitem>
          </itemizedlist>
        </note>
      </section>
    </section>

    <section>
      <title>Internationalization in Geomajas</title>

      <para>For internationalization, Geomajas uses the default GWT i18n
      implementation. For Geomajas specifically, the i18n is used in several
      places, each having it's own list of messages. Basically all i18n
      message definitions are located in the package
      <code>org.geomajas.gwt.client.i18n</code>, as are the properties files
      containing the translations.</para>

      <para>Several separate definitions have been created:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>MenuMessages</emphasis>: the
          <code>MenuMessages</code> defines parameterized string values that
          are used in the titles of <code>MenuAction</code> classes. Examples
          are the editing context menus.</para>
        </listitem>

        <listitem>
          <para><emphasis>ToolbarConstants</emphasis>: this defines strings
          that are used as tool tips when hovering over the buttons in the
          tool bar. This list of values is used by the
          <code>ToolbarAction</code> and <code>ToolbarSelectAction</code>
          classes. Note that for tool tips the "&amp;nbsp;" character is used
          instead of the default space.</para>
        </listitem>

        <listitem>
          <para><emphasis>AttributeMessages</emphasis>: .....</para>
        </listitem>

        <listitem>
          <para><emphasis>GlobalMessages</emphasis>: .....</para>
        </listitem>

        <listitem>
          <para><emphasis>LayerTreeMessages</emphasis>: .....</para>
        </listitem>

        <listitem>
          <para><emphasis>SearchMessages</emphasis>: .....</para>
        </listitem>
      </itemizedlist>

      <para>To avoid multiple instantiations of the constants and messages
      classes and have a central access point for all internationalization
      concerns, the <code>I18nProvider</code> class has been created. This
      class has static methods for accessing the constants and messages
      classes. Usage is as follows:</para>

      <programlisting>String dist = I18nProvider.getMenu().getMeasureDistanceString(totalDistance, radius); 
setContents( "&lt;div&gt;&lt;b&gt;" + I18nProvider.getMenu().distance() + "&lt;/b&gt;:&lt;/div&gt;&lt;div style='margin-top:5px;'&gt;" + dist + "&lt;/div&gt;"); </programlisting>
    </section>

    <section>
      <title>Unit testing GWT widgets</title>

      <para>A GWT unit test should inherit from the <code>GWTTestcase</code>
      base class and should be named <code>GwtTestXxx.java</code>. GWT unit
      tests are run inside a development mode environment and can refer to
      most of the GWT API. To run a GWT test case, run the Maven command
      <command>gwt:test </command>or execute the integration test
      phase.</para>
    </section>
  </chapter>

  <chapter id="chapter-gwt-widgets">
    <title>GWT widgets</title>

    <para>This second chapter of the GWT face describes all the widgets that
    Geomajas has added on top of the SmartGWT widget list. Each widget will be
    handled in detail so that developers might get a better understanding of
    what they are here for, and how to use them. Know that many of these
    widgets are closely connected, either through configuration or
    coding.</para>

    <section>
      <title>GraphicsWidget</title>

      <para>The <code>GraphicsWidget</code> is the basic widget that allows
      drawing onto a <code>GraphicsContext</code>, and catches mouse events at
      the same time. It implements the <code>MapContext</code> interface and
      provides it's own <code>MenuContext</code> implementation. As for the
      <code>VectorContext</code>, it delegates to a browser specific
      implementation (<code>VmlGraphicsContext</code> or
      <code>SvgGraphicsContext</code>). It is also responsible for handling
      <code>GraphicsController</code>s (only one global controller at a
      time!). The reason to place the controller handling here, is because we
      needed a default GWT widget to handle the events, not a SmartGWT widget.
      The SmartGWT events do not contain the actual DOM elements for
      MouseEvents, while the default GWT events do - for some functionality it
      is absolutely vital that it is well-known which DOM node was the target
      of an event.</para>

      <para>Using the MenuContext, this widget always has the coordinates of
      the latest right mouse click. Usually the right mouse button is used for
      drawing context menus. But sometimes it is necessary to have the DOM
      element onto which the context menu was clicked, to influence this menu.
      That is why this widget always stores this latest event (or at least
      it's DOM element id, and screen location).</para>

      <para>This widget is the bridge between the internal Svg or Vml
      rendering in GWT and the SmartGWT widget library. It is used internally
      in the MapWidget, but is not meant to be used directly by
      developers.</para>
    </section>

    <section>
      <title>MapWidget</title>

      <para>The main map for any Geomajas application using the GWT face. This
      widget controls the <code>MapModel</code>, the <code>MapView</code>
      objects, has an internal <code>GraphicsWidget</code> for the actual
      rendering, and much more. Being the most central of all widget, the
      MapWidget has quite a few responsibilities and options.</para>

      <para><emphasis role="bold">Map - initialization</emphasis></para>

      <para>A first responsibility of the map is the correct initialization of
      it's model and all layers from the configuration. When the MapWidget is
      added to the HTML (onDraw), it will automatically fetch the
      configuration from the server, and than initialize itself (more
      precisely, build the <code>MapModel</code>). When this is done, the
      <code>MapModel</code> will fire a <code>MapModelEvent</code>. Many other
      widgets wait for this moment to initialize themselves, as they often
      require the <code>MapModel</code>'s contents.</para>

      <para><emphasis role="bold">View - rendering</emphasis></para>

      <para>A second responsibility lies in the ability to render shapes. The
      <code>render()</code> method uses a <code>PainterVisitor</code> to
      recursively go through <code>Paintable</code> objects and look for the
      correct <code>Painter</code>. All <code>Painter</code> definitions must
      be registered in the <code>MapWidget</code>, by means of the
      <code>registerPainter()</code> and <code>unregisterPainter()</code>
      methods. Also the full list of <code>WorldPaintables</code> is stored
      within the <code>MapWidget</code>. For more information regarding the
      rendering, using the render method, visit the <link
      linkend="graphics"><corpauthor>rendering
      manual</corpauthor></link>.</para>

      <para>As an addition of the <code>Paintable</code> objects in
      screen-space, the definition of a <code>MapAddon</code> has been created
      as well. <code>MapAddons</code> are self regulating pieces of software
      that are visible at a certain location on the map (in screen space!),
      and optionally have attached behaviour. Examples are the Navigation
      buttons and the scale bar.</para>

      <para><emphasis role="bold">Controller</emphasis></para>

      <para>To add interactivity to a map, you can add two types of
      controllers: the <code>GraphicsController</code> and the GWT
      <code>MouseWheelHandler</code>. For both it is possible to apply a
      single instance using the <code>setController()</code> and
      <code>setMouseWheelController()</code> methods.</para>

      <para><emphasis role="bold">Options</emphasis></para>

      <para>On top of the previous list of responsibilities, the map also has
      a few options that allow certain functionality to be present or not. The
      following options are standard:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>navigationAddonEnabled</emphasis>: this option can
          be configured from within the configuration, and determines whether
          or not the navigation <code>MapAddon</code> is visible. This
          <code><code>MapAddon</code></code> is placed in the upper left
          corner of the map and allows the user to pan, zoom in and out, and
          zoom to maximum extent.</para>
        </listitem>

        <listitem>
          <para><emphasis>scaleBarEnabled</emphasis>: this option can be
          configured from within the configuration, and determines whether or
          not the scale bar is visible. This shows you the scale of the map by
          means of a bar of certain length, expressed in the preferred unit
          type (metric versus English).</para>
        </listitem>

        <listitem>
          <para><emphasis>zoomOnScrollEnabled</emphasis>: this option
          determines whether or not the <code>ZoomOnScrollController</code> is
          active by default. This allows zooming in and out on the map using
          the mouse wheel.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>MapWidget example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_mapwidget.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>OverviewMap</title>

      <para>The overview map is an extension of the <code>MapWidget</code>,
      which keeps the overview of a target
      <code><code>MapWidget</code></code>. It keeps track of the target map's
      view, and reacts whenever that target map changes it's view. The
      <classname>OverViewMap</classname> implements the
      <code>MapViewChangedHandler</code> to track the changes of it's target
      map. As it is an extension of a normal <code>MapWidget</code>, it has
      all the functionality of a normal map. So you can configure layers for
      an overview map, just as you would for a normal map.</para>

      <figure>
        <title>OverviewMap example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_overviewmap.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Toolbar</title>

      <para>The Geomajas tool bar is an extension of the SmartGWT
      <code>ToolStrip</code> widget, and allows for many different widgets to
      be added to it. A tool bar must be initialized with an instance of the
      <code>MapWidget</code> it is related to. When the <code>MapWidget</code>
      has successfully initialized itself, it's <code>MapModel</code> will
      fire the <code>MapModelEvent</code> saying so. The tool bar reacts on
      this event by searching in the map configuration for the correct list of
      tool bar buttons. The map configuration can contain tool ids to indicate
      the tools which need to be added, together with optional parameters.
      Using the <code>ToolbarRegistry</code>, which contains the mappings
      between these ids and the relevant <code>ToolbarAction</code> or
      <code>ToolbarModalAction</code> classes, the tool bar will initialize
      itself (for more info; see <link linkend="interaction">User
      Interaction</link>).</para>

      <para>Existing tools which can be defined include:</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis>EditMode</emphasis>: a ToolbarModalAction for
            editing on the map. Allows the user to create new objects in the
            selected layer, and allows updating and deleting of selected
            objects.</para>
          </listitem>

          <listitem>
            <para><emphasis>MeasureDistanceMode</emphasis>: a
            ToolbarModalAction which allows the user to measure distances on
            the map.</para>
          </listitem>

          <listitem>
            <para><emphasis>SelectionMode</emphasis>: allow selecting features
            either by clicking on them, or by dragging a rectangle, thus
            selecting the features which are inside the rectangle. You need an
            active (vector) layer for the selection to work. The right click
            menu allows clearing the selected features and toggling selection
            at the current position. Press shift or control while selecting to
            add the selection to the previously selected features. Possible
            parameters:</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>clickTimeout</emphasis>: when the button it
                  released in less than the number of milliseconds specified
                  here, then the selection is treated as a click. When it
                  takes longer, it is treated as dragging. Default is "500"
                  (ms).</para>
                </listitem>

                <listitem>
                  <para><emphasis>coverageRatio</emphasis>: ratio of the
                  feature which needs to be inside the selected area for the
                  feature to be selected. When this is "1.0" then the entire
                  feature needs to be inside the selection rectangle. Default
                  is "0.7".</para>
                </listitem>

                <listitem>
                  <para><emphasis>priorityToSelectedLayer</emphasis>: when
                  this is "true" selection will first check the selected
                  layer, and use default behaviour only if nothing is found in
                  that layer. Default behaviour is to try all visible layers,
                  from front to back.</para>
                </listitem>

                <listitem>
                  <para><emphasis>pixelTolerance</emphasis>: number of pixels
                  of tolerance allowed when trying to select features.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomIn</emphasis>: zoom in to the map at the
            location clicked (will be centered), using the zoom factor which
            is configured.</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>delta</emphasis>: zoom in factor, should be
                  &gt;1 to effectively zoom in.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomOut</emphasis>: zoom out of the map at the
            location clicked (will be centered), using the zoom factor which
            is configured.</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>delta</emphasis>: zoom in factor, should be
                  in the ]0,1[ range to effectively zoom out</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>PanMode</emphasis>: this action allows you to pan
            the screen by dragging. When keeping either the shift or control
            key down, it is also possible to indicate an area to zoom into
            (like <emphasis>ZoomToRectangleMode</emphasis>).</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomToRectangleMode</emphasis>: you can indicate a
            rectangle (by dragging) and it will zoom to make the selected area
            as big as possible while still entirely inside the map
            widget.</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomToSelection</emphasis>: first select some
            items on the map. After clicking on the the zoomToSelection button
            the map will be zoomed so that all selected items will fit nicely
            on the screen.</para>
          </listitem>

          <listitem>
            <para><emphasis>panToSelection</emphasis>: first select some items
            on the map. After clicking on the panToSelection button the map
            will be panned in such a way that the center of the selected items
            is in the center of the screen.</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomPrevious</emphasis>: go back to the previous
            zoom level (and location).</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomNext</emphasis>: go forward again, cancelling
            a click on <emphasis>ZoomPrevious</emphasis>.</para>
          </listitem>
        </itemizedlist></para>

      <figure>
        <title>Tool bar example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_toolbar.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>LayerTree</title>

      <para>This widget represents a view on the map model which is focused on
      layers. You see the map layers in a tree, just as they are configured.
      Accompanied with this view, there are buttons that define certain
      actions on these layers. Originally there are no buttons in this widget,
      so they have to be added manually or through configuration. These
      buttons can either be single actions or selectable buttons (similar to
      the <code>Toolbar</code> widget - see <link linkend="interaction">User
      Interaction</link>).</para>

      <para>Just like the tool bar, the <code>LayerTree</code> waits for the
      <code>MapModel</code> to be initialized, and also reacts to the
      <code>MapModelEvent</code>. The layer tree configuration is contained in
      the map configuration. When the <code>MapModelEvent</code> is fired, the
      <code>LayerTree</code> will read configuration to know the layer tree
      structure, which buttons to include,...</para>

      <para>Below you see a screen shot of a simple <code>LayerTree</code>
      where no layer has been selected (and thus all the buttons are
      disabled):</para>

      <figure>
        <title>LayerTree example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_layertree1.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Once a layer is selected, the <code>LayerTree</code> will ask all
      buttons whether they should be enabled for that layer. For example, the
      <code>org.geomajas.gwt.client.action.layertree.LabelAction</code>, which
      toggles a layer's labels, is only applicable on vector layers, so if the
      selected layer is a raster layer, that button will remain disabled. The
      same <code>LayerTree</code> with a selected layer looks like
      this:</para>

      <figure>
        <title>LayerTree with selected layer</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_layertree2.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <code>LayerTree</code> has few public methods, but it does
      quite a lot behind the screen. The tree is a SmartGWT
      <code>TreeGrid</code>, where the <code>LayerTree</code> adds handlers to
      the nodes and leaves (using <code>LeafClickHandler</code> and
      <code>FolderClickHandler</code>), which trigger layer selection in the
      <code>MapModel</code>. The <code>LayerTree</code> also listens to layer
      selection events, to adjust it's own appearance. For example, when a
      layer is selected, the proper node has to be selected and all the
      buttons updated.</para>

      <para>The <code>LayerTreeAction</code> and
      <code>LayerTreeModalAction</code> are also specifically designed to cope
      with the different stages that they should be able to display. The
      <code>LayerTreeModalAction</code> can be disabled, enabled and selected
      or enabled and deselected. For each it is imperative that clear markings
      are given. This means that different icons are usually used for the
      different stages. These different icons should be given to the actions
      at construction time.</para>

      <para>Currently the following actions are defined:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.VisibleAction</emphasis>:
          a <code>LayerTreeModalAction</code> that switches the visible flag
          on the selected layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.LabelAction</emphasis>:
          a <code>LayerTreeModalAction</code> that switches the display of
          labels for the selected layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.LayerRefreshAction</emphasis>:
          a <code>LayerTreeAction</code> that refreshes the selected layer on
          click.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Legend</title>

      <para>The <code>Legend</code> is a graphical widget that shows all
      styles for the currently visible vector layers. In that sense it is
      another view on the map model that only shows the style definitions that
      are currently relevant. Just like the map widget, the legend is built on
      <code>GraphicsWidget</code>. It reads the available layers from the map
      model and draws a legend to match the style of these layers.</para>

      <figure>
        <title>Legend</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/gwtface_widget_legend.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureListGrid</title>

      <para>The <code>FeatureListGrid</code> is a table listing the attributes
      of features within a single vector layer. Each feature is represented by
      a row in the grid, with at the top a header that shows the attribute
      label, as configured in the configuration. As only vector layers can
      contain features, the grid will be empty for raster layers.</para>

      <para>The <code>FeatureListGrid</code> has a few options that determine
      it's behaviour and appearance:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>selectionEnabled</emphasis>: enables or disables
          selection of features when selecting a row in the table. When this
          is enabled, the table will keep feature selection consistent with
          the map model. If the user selects a row, the feature will also be
          selected on the map.</para>
        </listitem>

        <listitem>
          <para><emphasis>allAttributesDisplayed</emphasis>: show all
          attributes (true) or only the 'identifying' attributes (false)?
          Attributes can be configured as "identifying" in the configuration.
          This difference allows for a select list of attributes to be visible
          in the grid, keeping overview. The user can always ask more details
          by double clicking the line.</para>
        </listitem>

        <listitem>
          <para><emphasis>editingEnabled</emphasis>: determines whether or not
          editing the attributes is allowed. When double clicking a row in the
          table, a <code>FeatureAttributeWindow</code> will appear, containing
          the feature of the selected row. This setting determines if that
          window allows editing or not.</para>
        </listitem>

        <listitem>
          <para><emphasis>idInTable</emphasis>: show the feature's id in the
          table. This is false by default, and should not really be
          necessary.</para>
        </listitem>
      </itemizedlist>

      <para>This table is an extension of the SmartGWT <code>ListGrid</code>
      widget. It automatically has grouping, filtering and sorting abilities
      (and much more...). The <code>FeatureListGrid</code> makes it possible
      to easily display features. You have to set the layer from which to
      display features. Then you can add features one by one. If no layer is
      set, then then "<code>addFeature</code>" method will not add any rows to
      the table. Setting the layer will automatically create the grid header,
      using the layer's attribute definitions.</para>

      <figure>
        <title>FeatureListGrid example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featurelistgrid.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureAttributeWindow</title>

      <para>The <code>FeatureAttributeWindow</code> is a floating window to
      display and enable editing of a feature's attributes and persist these
      changes. This widget is a <code>FeatureAttributeEditor</code> with some
      extra buttons like "save". When setting a feature, it first makes a
      clone so you are not editing the feature directly and changes are only
      applied when the save is clicked. This widget also checks whether or not
      all fields are valid, and will not allow saving when at least one of the
      fields is not valid.</para>

      <para>The <code>FeatureAttributeWindow</code> has the following
      options:</para>

      <itemizedlist>
        <listitem>
          <para>editingAllowed: is editing allowed? This must be set
          <emphasis>before</emphasis> the widget is actually drawn.</para>
        </listitem>

        <listitem>
          <para>editingEnabled: is editing currently enabled or not? This
          widget can toggle this value on the fly. When editing is enabled, it
          will display an editable attribute form with save, cancel and reset
          buttons. When editing is not enabled, these buttons will disappear,
          and a simple attribute form is shown that displays the attribute
          values, but does not allow editing. This effect only works when
          <emphasis>editingAllowed</emphasis> is true.</para>
        </listitem>
      </itemizedlist>

      <para>Below is a screen shot of a <code>FeatureAttributeWindow</code>
      with editing allowed but not enabled. Without the editing allowed, there
      would be now "edit" button. The button itself triggers setting editing
      enabled.</para>

      <figure>
        <title>FeatureAttributeWIndow, editing allowed but not enabled</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featureattributewindow.png"
                       width="60%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>ActivityMonitor</title>

      <para>This widget monitors client-server communication traffic, and
      displays that activity to the end-user. It's purpose is inform the user
      that a server request is in progress. For example, when the user zooms
      in, it can sometimes take a few seconds before everything is redrawn.
      This widget displays that traffic by listening to the
      <code>GwtCommandDispatcher</code> events. On the screen shot below, you
      can see the difference between it being passive and active:</para>

      <figure>
        <title>ActivityMonitor example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_activitymonitor.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>ScaleSelect</title>

      <para>Combo box for changing the scale on the map which can be added to
      a tool bar. It displays a list of possible scales to choose from, but
      also allows the user to type a specific scale. The scale select is
      constructed with a <code>MapView</code> as parameter. If this
      <code>MapView</code> contains pre-configured resolutions (zoom-steps -
      these can be set in the configuration), than the scale select will allow
      selection from these scales. If no resolutions are present, the scale
      select will automatically choose relevant scales to choose from.</para>

      <para>Using the <code>setScales()</code> method, one can always override
      the list of scales in the widget.</para>

      <figure>
        <title>ScaleSelect example</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/gwtface_widget_scaleselect.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureSearch</title>

      <para>Widget that supports searching for features on the attributes.
      Requires a value for <code>manualLayerSelection</code> at construction
      time. If true, a select box will be shown so the user can select what
      layer to search in. The possible list of layers consists of all the
      vector layers that are present in the map model. If false, this widget
      will search in the currently selected layer.</para>

      <para>When the "search" button is indicated, the search will be
      performed server-side. When the result returns, a
      <code>SearchEvent</code> is fired. This event holds a reference to the
      <code>VectorLayer</code> in which the search took place, and a list of
      all the features that were found. In order to do something with the
      results (such as displaying in a <code>FeatureListGrid</code>), add a
      <code>SearchHandler</code>. For the specific case of displaying the
      feature in a <code>FeatureListGrid</code>, there is a
      <code>DefaultSearchHandler</code> that already does this.</para>

      <para>Note that there is a limit to the number of features that are
      returned. By default this limit is set to 100. Modify
      <code>maximumResultSize</code> to change this. Note that a high limit
      can have a serious impact on performance and memory consumption!</para>

      <figure>
        <title>FeatureSearch example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featuresearch.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>
</part>
