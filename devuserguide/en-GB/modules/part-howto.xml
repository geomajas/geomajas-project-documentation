<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
  ~ This file is part of Geomajas, a component framework for building
  ~ rich Internet applications (RIA) with sophisticated capabilities for the
  ~ display, analysis and management of geographic information.
  ~ It is a building block that allows developers to add maps
  ~ and other geographic data capabilities to their web applications.
  ~
  ~ Copyright 2008-2010 Geosparc, http://www.geosparc.com, Belgium
  ~
  ~ This program is free software: you can redistribute it and/or modify
  ~ it under the terms of the GNU Affero General Public License as
  ~ published by the Free Software Foundation, either version 3 of the
  ~ License, or (at your option) any later version.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~ GNU Affero General Public License for more details.
  ~
  ~ You should have received a copy of the GNU Affero General Public License
  ~ along with this program.  If not, see <http://www.gnu.org/licenses/>.
  -->
<part id="part-howto">
  <title>How-to</title>

  <chapter id="ch-howto-command">
    <title>Writing your own commands</title>

    <para>A Geomajas command usually consist of three classes, the actual
    command (which implements the <code>Command</code> interface), and two
    data transfer objects, one to pass the request parameters (extending
    <code>CommandRequest</code>, <code>LayerIdCommandRequest</code> or
    <code>LayerIdsCommandRequest</code>), and one which carries the response
    (extending <code>CommandResponse</code>).</para>

    <para>It is important to assure your request object extends from
    LayerIdCommandRequest or LayerIdsRequest when one of the parameters is the
    layer id (or a list thereof). This can be used by the command dispatcher
    to assure the layer specific (transaction) interceptors are called.</para>

    <para>To create a new command we recommend you use a similar package
    structure as we used in the geomajas-extension-command module. That is to
    create a "command" package with under that a "dto" package which contains
    all the request and response objects, and to put the actual commands in
    sub packages based on some kind of grouping. This helps to automatically
    determine a sensible command name.</para>

    <para>The basic command implementation looks like this:</para>

    <xi:include href="../listing/ExampleCommand.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>Note the presence of the "@Component" annotation which assures the
    command is registered. You could add the name under which the command
    needs to be registered in the annotation, but when that is omitted, the
    default command name is derived from the fully qualified class name. In
    the example given here this results in command name
    "command.mysuper.DoIt".</para>

    <para>The default way to determine the command name assumes there is a
    package named "command" in the fully qualified name of the implementing
    class. It will remove everything before that. It will then remove a
    "Command" suffix if any. Lastly, it will remove duplication between the
    intermediate package (between "command" and the class name) and the class
    name itself. Some examples:</para>

    <para><table>
        <title>Samples of command name resolution</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Fully qualified class name</entry>

              <entry>Command name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>my.app.command.DoIt</entry>

              <entry>command.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoIt</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.SuperDoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItSuperCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoIt</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandSuperDoIt</entry>

              <entry>command.super.CommandSuperDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoItSuper</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para>You have to include a line in your Spring configuration to scan
    class files for annotation to make the components available. For the case
    above, this could be done by including the following XML fragment in one
    of your Spring configuration files.</para>

    <xi:include href="../listing/ExampleCommandScan.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>The command will be executed using a singleton. The use of object
    variables is not recommended. Any object variables will be shared amongst
    all command invocation, which can be coming from multiple threads at the
    same time.</para>

    <para>Note that it is not mandatory to create your own request and
    response object classes. If you don't require any parameters you can use
    <code>EmptyCommandRequest</code> as request class. If you only require a
    layer id, then use <code>LayerIdCommandRequest</code>. If you only return
    a success code, you could use the <code>SuccessCommandResponse</code>
    class.</para>

    <para>You have to take care that all objects which are referenced by your
    request and response objects are actually serializable for the faces in
    which the commands need to be used. For the dojo face this may require the
    use of the "<code>@Json</code>" annotation to exclude fields. For GWT you
    have to assure the no-arguments constructor exists and that the class can
    be compiled by GWT (no Hibernate enhanced classes, no use of
    "<code>super.clone()</code>",...).</para>

    <para>When the commands are included in a separate module, you should
    assure the sources are available as these are needed for GWT compilation.
    This can easily be done using the Maven source plugin.</para>

    <xi:include href="../listing/MavenSourcePlugin.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>Actually including the sources can then be done using a dependency
    like the following (this includes the staticsecurity module, both the
    actual code and the sources). You could set "provided" scope on the source
    dependency to exclude it from the war file. However, this may prevent use
    of GWT development mode.</para>

    <xi:include href="../listing/StaticSecurityDependency.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para></para>
  </chapter>

  <chapter id="ch-howto-plugin">
    <title>Create a plug-in</title>

    <para>The general procedure for creating a new plug-in is described here.
    Additional information for specific types of plug-ins is described in
    subsequent chapters.</para>

    <section>
      <title>Using the plug-in archetype</title>

      <para>TODO.....</para>
    </section>

    <section>
      <title>Plug-in structure</title>

      <para>TODO.....</para>
    </section>

    <section>
      <title>Plug-in declaration and dependencies</title>

      <para>TODO.....</para>
    </section>
  </chapter>

  <chapter id="ch-howto-layer">
    <title>Create a layer plug-in</title>

    <para>Layers allow access to data which needs to be displayed in a
    map.</para>

    <para>For the existing layers, the details about configuring you map to
    include that layer are included in the <link
    linkend="backend-ch-configuration">configuration</link> section
    above.</para>

    <section>
      <title>Writing your own layer</title>

      <para>TODO.....</para>
    </section>
  </chapter>

  <chapter id="ch-howto-security">
    <title>Create a security plug-in</title>

    <section>
      <title>Writing your own security service</title>

      <para>TODO.....</para>
    </section>
  </chapter>
</part>
